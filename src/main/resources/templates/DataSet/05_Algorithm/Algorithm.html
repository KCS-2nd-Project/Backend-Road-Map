<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Algorithm</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="3dab5fd5-0534-44f6-8bf2-30c532b56f83" class="page sans"><header><h1 class="page-title">Algorithm</h1><p class="page-description"></p></header><div class="page-body"><p id="452f5f74-35b5-49cc-b0a1-7338f1c989e6" class="">
</p><h2 id="26008bb4-ef77-4c82-9dc5-5e3b923fead0" class=""><strong>거품 정렬(Bubble Sort)</strong></h2><p id="247602ca-b956-4c6f-8ccc-806475a67945" class="">
</p><h3 id="d0a31f03-65fc-4a25-ae3b-2653e416986e" class="">거품 정렬이란</h3><p id="fdbc9aae-4773-4252-9d48-1874c78e7eff" class="">Bubble Sort는 Selection Sort와 유사한 알고리즘으로  서로 인전합 두 원소의 대소를 비교하고, 조건에 맞지 않는다면 자리를 교환하며8 정렬하는 알고리즘이다. </p><p id="214dc4ec-135b-4863-a0b4-c075102e32a3" class="">이름의 유래로는 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어졌다고 한다.</p><p id="b22a1aeb-4d3a-49db-8ce9-d1a1acb5025a" class="">
</p><h3 id="5f7dfaf3-e1a7-4a80-ab9a-f5bff99359c3" class=""><strong>Process (Ascending)</strong></h3><ol type="1" id="4e3ca477-36b9-47e9-8c60-1f4179e0e9ee" class="numbered-list" start="1"><li>“1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 세 번째 원소와 네 번째 원소를, …” 와 같은 방법으로 (마지막-1)번째 원소와 마지막 원소를 비교하여 조건에 맞지 않는다면 서로 교환한다.</li></ol><ol type="1" id="023066f3-cc49-45c2-88c5-4ac9e849e63c" class="numbered-list" start="2"><li>1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 원소까지는 정렬에서 제외된다. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.</li></ol><p id="52888105-126a-4a63-97e2-c286b8dc38d3" class="">
</p><h2 id="9efa6de8-fbcc-4749-9b91-d49194203b14" class=""><strong>Java Code (Ascending)</strong></h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="87ff441f-8302-403a-96a6-4fb3b6cd4d9d" class="code"><code class="language-Java">void bubbleSort(int[] arr) {
    int temp = 0;
	for(int i = 0; i &lt; arr.length; i++) {       // 1.
		for(int j= 1 ; j &lt; arr.length-i; j++) { // 2.
			if(arr[j-1] &gt; arr[j]) {             // 3.
                // swap(arr[j-1], arr[j])
				temp = arr[j-1];
				arr[j-1] = arr[j];
				arr[j] = temp;
			}
		}
	}
	System.out.println(Arrays.toString(arr));
}</code></pre><ol type="1" id="84d4726f-0815-4cf2-8625-8ad52abae172" class="numbered-list" start="1"><li>제외될 원소의 갯수를 의미한다. 1회전이 끝난 후, 배열의 마지막 위치에는 가장 큰 원소가 위치하기 때문에 하나씩 증가시켜준다.</li></ol><ol type="1" id="5b79f10b-ac7e-4a83-9160-ebebb4a07a6c" class="numbered-list" start="2"><li>원소를 비교할 index를 뽑을 반복문이다. j는 현재 원소를 가리키고, j-1은 이전 원소를 가리키게 되므로, j는 1부터 시작하게 된다.</li></ol><ol type="1" id="a7859744-e29e-4e2f-a53e-0332104be9ff" class="numbered-list" start="3"><li>현재 가르키고 있는 두 원소의 대소를 비교한다. 해당 코드는 오름차순 정렬이므로 현재 원소보다 이전 원소가 더 크다면 이전 원소가 뒤로 가야하므로 서로 자리를 교환해준다.</li></ol><p id="f41bf037-9352-44e9-b319-0d34468abc01" class="">
</p><h3 id="ef35ff25-6903-4a04-834d-fb1674b8e036" class=""><strong>GIF로 이해하는 Bubble Sort</strong></h3><p id="67643271-77ad-4fca-a8f7-6a600eb76bd4" class=""><a href="https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/bubble-sort-001.gif"><strong>(opens new window)</strong></a></p><figure id="0325200f-69e1-4588-ae27-7076c44912de" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/bubble-sort-001.gif"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/bubble-sort-001.gif"/></a></figure><p id="47a2b092-4801-4f83-88fd-031b5e7ca387" class="">
</p><h3 id="4843894d-08be-4a67-ad92-1bb1bdf2d79e" class=""><strong>시간복잡도</strong></h3><p id="fb57f2a6-8f25-4d79-a9f3-337eff74ab91" class="">시간복잡도를 계산하면, <code>(n-1) + (n-2) + (n-3) + .... + 2 + 1 =&gt; n(n-1)/2</code>이므로, <strong>O(n^2)</strong> 이다. 또한, Bubble Sort는 정렬이 돼있던 안돼있던, 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간복잡도가 <strong>O(n^2)</strong> 으로 동일하다.</p><p id="f7c8b59d-3226-43ed-ac88-a087f63b0397" class="">
</p><h3 id="630f5146-ba49-4e90-831f-d6b9711d3f29" class=""><strong>공간복잡도</strong></h3><p id="797ede73-c36f-4fbb-ae99-4e59af5bd6b3" class="">주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 <strong>O(n)</strong> 이다.</p><p id="9cf679e4-67a2-4edc-88ed-a683d5fb8387" class="">
</p><h3 id="84b4b2ef-fda6-4a70-bdb0-27df7c5c7dd4" class=""><strong>장점</strong></h3><ul id="d71b1380-6f1d-4225-804b-dcb6e6d192d0" class="bulleted-list"><li style="list-style-type:disc">구현이 매우 간단하고, 소스코드가 직관적이다.</li></ul><ul id="64d7d2e9-f1a9-4357-9920-1b9037c64213" class="bulleted-list"><li style="list-style-type:disc">정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. =&gt; 제자리 정렬(in-place sorting)</li></ul><ul id="9c453975-9b54-4eea-b327-4bd6797eb046" class="bulleted-list"><li style="list-style-type:disc">안정 정렬(Stable Sort) 이다.</li></ul><p id="55350667-221b-4f27-b37e-2d412c2296c3" class="">
</p><h3 id="cd5ea25b-1c48-46f7-8f99-6e1c0fbbc5fb" class=""><strong>단점</strong></h3><ul id="1ede5255-57a6-4d6c-a739-0976040d4825" class="bulleted-list"><li style="list-style-type:disc">시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.</li></ul><ul id="726b4560-fd80-4342-b1fb-f12db14fa9c5" class="bulleted-list"><li style="list-style-type:disc">정렬 돼있지 않은 원소가 정렬 됐을때의 자리로 가기 위해서, 교환 연산(swap)이 많이 일어나게 된다.</li></ul><p id="7e17f040-71a6-4c84-83ae-6b5da8a766cd" class="">
</p><ul id="2259c98c-df44-46be-8306-7694faed5013" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="0a5a28e2-d151-4451-9ae2-6da5007e2e95" class=""><a href="https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html">https://gyoogle.dev/blog/algorithm/Bubble Sort.html</a></p><p id="8ca725d3-474e-49f5-a8f0-b0511d54b9a7" class="">
</p><hr id="9f9ca4a4-2214-4a8d-abf3-224790729486"/><p id="123fc676-418a-4d39-a6e9-5115cef10f4b" class="">
</p><h2 id="d8383ac8-031a-4ef5-b309-769acfd1bf44" class=""><strong>선택 정렬(Selection Sort)</strong></h2><p id="81811b65-f6ad-4ef7-ba89-9f2ef37622bc" class="">
</p><h3 id="b4c14481-d027-4396-bf8d-29b289776d1e" class="">선택 정렬이란</h3><p id="0a29b21f-6904-4f64-a569-9e7016cac964" class="">Selection Sort는 Bubble Sort과 유사한 알고리즘으로, <strong>해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘</strong>이다.</p><p id="7b83b4b7-2b6c-4630-8eaa-07669af94d6c" class="">Selection Sort와 Insertion Sort를 헷갈려하는 사람들이 종종 있는데, Selection Sort는 배열에서 <strong>해당 자리를 선택하고 그 자리에 오는 값을 찾는 것</strong>이라고 생각하면 편하다.</p><p id="4504aaec-2fee-49e4-83cd-d1abf3edbfc5" class="">
</p><h3 id="2c3dd0b4-08b5-4120-9a52-5e056d2a1218" class=""><strong>Process (Ascending)</strong></h3><ol type="1" id="c3be4c8c-8aaf-465a-b064-91398801d453" class="numbered-list" start="1"><li>주어진 배열 중에 최소값을 찾는다.</li></ol><ol type="1" id="87cc6d1a-1301-4880-807c-4aebe96a564b" class="numbered-list" start="2"><li>그 값을 맨 앞에 위치한 값과 교체한다. (pass)</li></ol><ol type="1" id="aaf47ce3-7c50-4d95-a6d6-f1c4f05c4dea" class="numbered-list" start="3"><li>맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.</li></ol><p id="330a010c-2a57-4f6c-98f2-515e3d6410d2" class="">
</p><h3 id="0e122b89-6b15-41e6-b5a8-6fcf7f5721d7" class=""><strong>Java Code (Ascending)</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3cbad530-5f8f-4e87-8d32-d26e0029d168" class="code"><code class="language-Java">void selectionSort(int[] arr) {
    int indexMin, temp;
    for (int i = 0; i &lt; arr.length-1; i++) {        // 1.
        indexMin = i;
        for (int j = i + 1; j &lt; arr.length; j++) {  // 2.
            if (arr[j] &lt; arr[indexMin]) {           // 3.
                indexMin = j;
            }
        }
        // 4. swap(arr[indexMin], arr[i])
        temp = arr[indexMin];
        arr[indexMin] = arr[i];
        arr[i] = temp;
  }
  System.out.println(Arrays.toString(arr));
}</code></pre><ol type="1" id="d4eed37f-bb35-4817-9353-6268384300a5" class="numbered-list" start="1"><li>우선, 위치(index)를 <strong>선택</strong>해준다.</li></ol><ol type="1" id="daab9563-6245-4503-a402-94d868d75ea2" class="numbered-list" start="2"><li>i+1번째 원소부터 선택한 위치(index)의 값과 비교를 시작한다.</li></ol><ol type="1" id="709c8db3-217c-4b93-8308-824bc1d6eab8" class="numbered-list" start="3"><li>오름차순이므로 현재 선택한 자리에 있는 값보다 순회하고 있는 값이 작다면, 위치(index)를 갱신해준다.</li></ol><ol type="1" id="924b49c2-1231-4830-be87-33d7e845b9d0" class="numbered-list" start="4"><li>&#x27;2&#x27;번 반복문이 끝난 뒤에는 indexMin에 &#x27;1&#x27;번에서 선택한 위치(index)에 들어가야하는 값의 위치(index)를 갖고 있으므로 서로 교환(swap)해준다.</li></ol><p id="76444a4f-04d2-4599-80fa-1dd51e6de76e" class="">
</p><h3 id="54f39052-863d-47fb-913c-94f138a1a2cb" class=""><strong>GIF로 이해하는 Selection Sort</strong></h3><p id="0bec8032-ea6d-4086-b6a7-680d684d1a91" class=""><a href="https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/selection-sort-001.gif"><strong>(opens new window)</strong></a></p><figure id="156fb5dc-c80c-4b30-bcab-087c7374f416" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/selection-sort-001.gif"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/selection-sort-001.gif"/></a></figure><p id="7e091e96-62a7-4365-be03-691b992fcbae" class="">
</p><h3 id="a1f5d3a8-c7d6-4e82-a86d-64735d639968" class=""><strong>시간복잡도</strong></h3><p id="f691c6ea-38fa-4098-b2b0-604520ddc7d1" class="">데이터의 개수가 n개라고 했을 때,</p><ul id="a2484e07-9237-4c84-b2fb-1fde951a8392" class="bulleted-list"><li style="list-style-type:disc">첫 번째 회전에서의 비교횟수 : 1 ~ (n-1) =&gt; n-1</li></ul><ul id="5e94e8f1-e3bc-402f-ae9a-e830f789fc8e" class="bulleted-list"><li style="list-style-type:disc">두 번째 회전에서의 비교횟수 : 2 ~ (n-1) =&gt; n-2<p id="bebe9788-e302-4d9b-8236-7f72b201a3e9" class="">...</p></li></ul><ul id="aa97597a-5b97-4a1f-a318-81c3abefe473" class="bulleted-list"><li style="list-style-type:disc"><code>(n-1) + (n-2) + .... + 2 + 1 =&gt; n(n-1)/2</code></li></ul><p id="dd44b8fd-e8af-4adf-9a9f-c06f7bd6d1c9" class="">비교하는 것이 상수 시간에 이루어진다는 가정 아래, n개의 주어진 배열을 정렬하는데 O(n^2) 만큼의 시간이 걸린다. 최선, 평균, 최악의 경우 시간복잡도는 <strong>O(n^2)</strong> 으로 동일하다.</p><p id="9716a7c8-971a-49bb-8707-552408cf7b63" class="">
</p><h3 id="dc8f4bc5-c96e-43ca-bbf1-09876a73b191" class=""><strong>공간복잡도</strong></h3><p id="7a89ad29-e19a-4016-9131-608e8b7db3ff" class="">주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 <strong>O(n)</strong> 이다.</p><p id="a4743cc0-a4a8-4bc5-8b18-b7d1b0daa905" class="">
</p><h3 id="7434eba4-b626-402f-a51c-d5a60f62e419" class=""><strong>장점</strong></h3><ul id="fc33de0f-ea65-4bab-bf3d-ead9c9d76aad" class="bulleted-list"><li style="list-style-type:disc">Bubble sort와 마찬가지로 알고리즘이 단순하다.</li></ul><ul id="50bde898-f203-44ef-93b1-d2139f52f85f" class="bulleted-list"><li style="list-style-type:disc">정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.</li></ul><ul id="1f2a8790-6c8c-4279-b6d8-8da80c424c95" class="bulleted-list"><li style="list-style-type:disc">Bubble Sort와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. =&gt; 제자리 정렬(in-place sorting)</li></ul><p id="334c925e-5a1c-43d2-bec6-491a1fc84036" class="">
</p><h3 id="62304dab-089b-46c3-b4e2-2e0ce6578e4e" class=""><strong>단점</strong></h3><ul id="2a11af79-8268-4362-b65d-49defed396db" class="bulleted-list"><li style="list-style-type:disc">시간복잡도가 O(n^2)으로, 비효율적이다.</li></ul><ul id="62db0acf-ab79-409d-bcc7-e0ff2b0a6557" class="bulleted-list"><li style="list-style-type:disc"><strong>불안정 정렬(Unstable Sort)</strong> 이다.</li></ul><p id="30ab0d8f-99ad-4e8f-81a6-f6aaf51b87bc" class="">
</p><ul id="89dfa67a-278e-4896-bc56-beb3c40a06cf" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="d6b78c02-e765-465d-995b-2ba83ef735d8" class=""><a href="https://gyoogle.dev/blog/algorithm/Selection%20Sort.html">https://gyoogle.dev/blog/algorithm/Selection Sort.html</a></p><p id="4511019d-f08c-4a20-9d8a-829494eda448" class="">
</p><hr id="015887d6-ac27-4d47-b712-f5c3a42a57df"/><p id="e599b5c7-cdc2-493d-83db-01b4bb240cbf" class="">
</p><h2 id="c7f7c3ac-13a7-4173-b9c7-f7282873f932" class=""><strong>삽입 정렬(Insertion Sort)</strong></h2><p id="19e24548-3ede-4dda-9768-1d7567e998f1" class="">
</p><h3 id="981e7013-bd7a-4039-9631-213f2e12fec6" class="">삽입 정렬이란</h3><p id="f721e02b-b32a-4a51-ba93-41b84b75a133" class="">손 안의 카드를 정렬하는 방법과 유사하다.</p><p id="43ce324e-9d85-40f5-a949-79129df83369" class="">Insertion Sort는 Selection Sort와 유사하지만, 좀 더 효율적인 정렬 알고리즘이다.</p><p id="d38b0a94-5a81-4cb3-8fcf-63d1d7344042" class="">Insertion Sort는 <strong>2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입</strong> 하여 정렬하는 알고리즘이다.</p><p id="3e2fefeb-12e6-4553-b5b3-11480c93ee77" class="">최선의 경우 O(N)이라는 엄청나게 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘이다.</p><p id="b5ce1c55-b736-4ee1-8c2a-c6ddf02599ea" class="">
</p><h3 id="b4df3c28-f310-4463-932a-726b0d8ce209" class=""><strong>Process (Ascending)</strong></h3><ol type="1" id="e2834810-f038-4b0d-b91d-eb37aee2daa8" class="numbered-list" start="1"><li>정렬은 2번째 위치(index)의 값을 temp에 저장한다.</li></ol><ol type="1" id="9b04390b-594c-438f-b82a-ac8fbd8dc573" class="numbered-list" start="2"><li>temp와 이전에 있는 원소들과 비교하며 삽입해나간다.</li></ol><ol type="1" id="961d84c3-2acc-4cff-826a-67fb57bcd500" class="numbered-list" start="3"><li>&#x27;1&#x27;번으로 돌아가 다음 위치(index)의 값을 temp에 저장하고, 반복한다.</li></ol><p id="66d0a37c-847c-4361-bc75-501b35459dd0" class="">
</p><h3 id="2c39b592-7053-4329-9452-d671a16d7edf" class=""><strong>Java Code (Ascending)</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="35728d7b-364d-4ab4-b4b7-65b57c4100ed" class="code"><code class="language-Java">void insertionSort(int[] arr)
{
   for(int index = 1 ; index &lt; arr.length ; index++){ // 1.
      int temp = arr[index];
      int prev = index - 1;
      while( (prev &gt;= 0) &amp;&amp; (arr[prev] &gt; temp) ) {    // 2.
         arr[prev+1] = arr[prev];
         prev--;
      }
      arr[prev + 1] = temp;                           // 3.
   }
   System.out.println(Arrays.toString(arr));
}</code></pre><ol type="1" id="dcaa71c0-2e09-4d0d-bc1d-cc28e3545486" class="numbered-list" start="1"><li>첫 번째 원소 앞(왼쪽)에는 어떤 원소도 갖고 있지 않기 때문에, 두 번째 위치(index)부터 탐색을 시작한다. temp에 임시로 해당 위치(index) 값을 저장하고, prev에는 해당 위치(index)의 이전 위치(index)를 저장한다.</li></ol><ol type="1" id="5bf59bc6-ab1e-4751-8945-d7492cb6bc89" class="numbered-list" start="2"><li>이전 위치(index)를 가리키는 prev가 음수가 되지 않고, 이전 위치(index)의 값이 &#x27;1&#x27;번에서 선택한 값보다 크다면, 서로 값을 교환해주고 prev를 더 이전 위치(index)를 가리키도록 한다.</li></ol><ol type="1" id="8dbfd484-9e95-47aa-83b6-d3bb0e8fbeea" class="numbered-list" start="3"><li>&#x27;2&#x27;번에서 반복문이 끝나고 난 뒤, prev에는 현재 <strong>temp 값보다 작은 값들 중 제일 큰 값의 위치(index)</strong> 를 가리키게 된다. 따라서, (prev+1)에 temp 값을 삽입해준다.</li></ol><p id="fb6c3441-1aea-4ebc-86e0-878ee5c43401" class="">
</p><h3 id="d837ecb3-d047-4a42-bde0-469c602c4055" class=""><strong>GIF로 이해하는 Insertion Sort</strong></h3><p id="83eb7612-7bf8-421b-a43b-36b1d01c7c46" class=""><a href="https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/insertion-sort-001.gif"><strong>(opens new window)</strong></a></p><figure id="c6df6f39-36c8-43ab-bab5-6766d2693de9" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/insertion-sort-001.gif"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/insertion-sort-001.gif"/></a></figure><p id="c64569e0-f030-48a5-b5e1-505ae88cb331" class="">
</p><h3 id="03f3bea7-ad76-474f-a003-548ebe002695" class=""><strong>시간복잡도</strong></h3><p id="3c229698-ff93-429b-8d5d-4a189f7e9b9a" class="">최악의 경우(역으로 정렬되어 있을 경우) Selection Sort와 마찬가지로, <code>(n-1) + (n-2) + .... + 2 + 1 =&gt; n(n-1)/2</code> 즉, <strong>O(n^2)</strong> 이다.</p><p id="0242e313-2573-4dea-a17e-12012a9b99de" class="">하지만, 모두 정렬이 되어있는 경우(Optimal)한 경우, 한번씩 밖에 비교를 안하므로 <strong>O(n)</strong> 의 시간복잡도를 가지게 된다. 또한, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문이다.</p><p id="6b87c955-558b-48f8-b014-3d2d12680045" class="">최선의 경우는 <strong>O(n)</strong> 의 시간복잡도를 갖고, 평균과 최악의 경우 <strong>O(n^2)</strong> 의 시간복잡도를 갖게 된다.</p><p id="36948eda-ff21-4bc9-a5b0-3360c58b7a47" class="">
</p><h3 id="e741ca62-d24a-4eae-9542-87a409dd764f" class=""><strong>공간복잡도</strong></h3><p id="10b6aad4-09eb-42e6-86c9-cbd47586d358" class="">주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 <strong>O(n)</strong> 이다.</p><p id="dc72baac-55b2-48e5-8e50-f5d84b3fd2db" class="">
</p><h3 id="ae797837-d980-4603-a7b0-5f3f21cc3ee9" class=""><strong>장점</strong></h3><ul id="53fa29cc-76b7-4ad4-a846-efb45c30a5f5" class="bulleted-list"><li style="list-style-type:disc">알고리즘이 단순하다.</li></ul><ul id="d56dab58-44c3-42f4-b84f-a865304f8e76" class="bulleted-list"><li style="list-style-type:disc">대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.</li></ul><ul id="1863a595-43f0-4641-8e60-755e5c3f7371" class="bulleted-list"><li style="list-style-type:disc">정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. =&gt; 제자리 정렬(in-place sorting)</li></ul><ul id="a43c8db0-76fb-475d-bc7c-d48e5ed205f4" class="bulleted-list"><li style="list-style-type:disc"><strong>안정 정렬(Stable Sort)</strong> 이다.</li></ul><ul id="567a3c4f-1e15-4b95-9231-1d43d946bbc8" class="bulleted-list"><li style="list-style-type:disc">Selection Sort나 Bubble Sort과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.</li></ul><ul id="be326c86-6f13-48c4-8f45-28052de78479" class="bulleted-list"><li style="list-style-type:disc"></li></ul><h3 id="ba01ab6a-704f-4dd4-b972-e45eb99cd0f1" class=""><strong>단점</strong></h3><ul id="e5fe7539-be57-4f2b-988d-cfdc005cd8a8" class="bulleted-list"><li style="list-style-type:disc">평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다.</li></ul><ul id="fff1a23b-7d58-4aae-8e06-f22e598fee75" class="bulleted-list"><li style="list-style-type:disc">Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.</li></ul><p id="82751211-c0dd-47d6-83f1-08bf411a88c7" class="">
</p><ul id="47061af6-7178-4012-a918-9686bdb4dccd" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="3424e9a9-245b-42d1-86a5-c8ede1b40017" class=""><a href="https://gyoogle.dev/blog/algorithm/Insertion%20Sort.html">https://gyoogle.dev/blog/algorithm/Insertion Sort.html</a></p><p id="e7fb3709-4e98-43b1-b9fc-365e88987630" class="">
</p><hr id="e09294d3-1090-44c7-af9f-7e24e6d62408"/><p id="b802f8f3-997a-406c-bbe1-12149e0c2c7d" class="">
</p><h2 id="2a5d3e5c-57ff-4de3-8ab5-4d0e320a0617" class=""><strong>퀵 정렬(Quick Sort)</strong></h2><p id="43df262a-b79b-4aef-a6c3-4cd89bb96d40" class="">
</p><h3 id="016b67d0-9579-49c8-a285-af45c44c7f5e" class=""><strong>Abstract</strong></h3><p id="e3343f89-6dd3-48c8-9046-7019fec5d17c" class="">Quick Sort은 <strong>분할 정복(divide and conquer) 방법</strong> 을 통해 주어진 배열을 정렬한다.</p><ul id="84b6a659-6dca-4570-aea3-00e5f5824bfd" class="bulleted-list"><li style="list-style-type:disc"><code>[분할 정복(divide and conquer) 방법]<br/>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.<br/></code></li></ul><p id="7857d8ef-a0b1-40eb-937c-f7f6c183d5f2" class="">Quick Sort은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 또한 Merge Sort와 달리 Quick Sort는 배열을 비균등하게 분할한다.</p><p id="c8cb03f2-a416-46b1-93a1-c3b9194bb101" class="">
</p><h3 id="9061c960-fc7d-4234-be10-d91a6106a0db" class=""><strong>Process (Ascending)</strong></h3><ol type="1" id="e622a14b-8de4-4cb5-80f2-3f9e5f68f779" class="numbered-list" start="1"><li>배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 <strong>피벗(pivot)</strong> 이라고 한다.</li></ol><ol type="1" id="29a5d403-6a8e-424c-94a5-81aeb23e1ac1" class="numbered-list" start="2"><li>피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 <strong>분할(Divide)</strong> 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.</li></ol><ol type="1" id="8da5c746-5bd8-4657-bd35-d508917aebc8" class="numbered-list" start="3"><li>분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.</li></ol><p id="b8998e40-42e7-421c-87f4-3f0425604ed3" class="">재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.</p><p id="fbea5443-9861-43ce-9635-be42d0fc9d1c" class="">
</p><h3 id="f9347265-5cd3-47f7-b4a9-73e1b26833aa" class=""><strong>Java Code (Ascending)</strong></h3><p id="a99a3fe9-e8e0-48f8-9d56-8730bf964497" class="">퀵 정렬은 다음의 단계들로 이루어진다.</p><ul id="74243720-6fde-44fc-ac6a-d792eccf8421" class="bulleted-list"><li style="list-style-type:disc">정복 (Conquer)<p id="919f39c2-65a6-4c2c-b78c-3ea5eb494c6f" class="">부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="687b6566-728c-473a-8769-b744d0948acd" class="code"><code class="language-Java">public void quickSort(int[] array, int left, int right) {
    if(left &gt;= right) return;
    
    // 분할 
    int pivot = partition(); 
    
    // 피벗은 제외한 2개의 부분 배열을 대상으로 순환 호출
    quickSort(array, left, pivot-1);  // 정복(Conquer)
    quickSort(array, pivot+1, right); // 정복(Conquer)
}</code></pre></li></ul><ul id="c9464d8e-f77f-44fe-8168-aab375dedabf" class="bulleted-list"><li style="list-style-type:disc">분할 (Divide)<p id="ebdf43fe-186c-4c3b-ba18-bdfb740f5a3f" class="">입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열 <strong>(피벗을 중심으로 왼쪽 : 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)</strong> 로 분할한다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="68873588-9a15-4135-9bc1-dc390a019132" class="code"><code class="language-Java">public int partition(int[] array, int left, int right) {
    /**
    // 최악의 경우, 개선 방법
    int mid = (left + right) / 2;
    swap(array, left, mid);
    */
    
    int pivot = array[left]; // 가장 왼쪽값을 피벗으로 설정
    int i = left, j = right;
    
    while(i &lt; j) {
        while(pivot &lt; array[j]) {
            j--;
        }
        while(i &lt; j &amp;&amp; pivot &gt;= array[i]){
            i++;
        }
        swap(array, i, j);
    }
    array[left] = array[i];
    array[i] = pivot;
    
    return i;
}</code></pre><p id="10cc56ca-26b1-457a-92cb-db7491b6b75b" class="">
</p></li></ul><h3 id="10e75fb3-6e00-45f4-8569-d8038cdc44a4" class=""><strong>Quick Sort 개선</strong></h3><p id="da61f2b9-20cf-43ab-8552-c4cf1d974266" class="">partition() 함수에서 <strong>피벗 값이 최소나 최대값으로 지정되어 파티션이 나누어지지 않았을 때,</strong> O(n^2)에 대한 시간복잡도를 가진다.</p><p id="564d259c-5519-4aef-8956-8a3332792838" class="">즉, 정렬하고자 하는 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있으면 O(n^2)의 시간복잡도를 가진다. 이때, 배열에서 가장 앞에 있는 값과 중간값을 교환해준다면 확률적으로나마 시간복잡도 O(nlog₂n)으로 개선할 수 있다. 하지만, 이 방법으로 개선한다해도 <code>Quick Sort의 최악의 시간복잡도가 O(nlog₂n)가 되는 것은 아니다.</code></p><p id="48c3a3b9-c7d0-45ea-99a1-a32609e883ac" class="">
</p><h3 id="08409e98-55fc-429d-ba74-13bb07d76c02" class=""><strong>GIF로 이해하는 Quick Sort</strong></h3><p id="380ea454-89b3-41ff-9b75-59f8c017881f" class=""><a href="https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/quick-sort-001.gif"><strong>(opens new window)</strong></a></p><figure id="ade95117-86ac-4b2a-bd81-e6a2e82df0d1" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-001.gif"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-001.gif"/></a></figure><p id="021017c9-b4ea-4878-933f-c7cc455dc378" class="">
</p><h3 id="6e24fa93-7834-4808-824c-d12c476d999b" class=""><strong>시간복잡도</strong></h3><ul id="98a8045f-dbc3-4fb8-9450-1f756eef82c5" class="bulleted-list"><li style="list-style-type:disc"><strong>최선의 경우(Best cases) : T(n) = O(nlog₂n)</strong><p id="fdecb5b8-859d-469b-92ad-ace935a2c53d" class="">01.비교 횟수 <code>(log₂n)</code><div class="indented"><p id="dcfe794a-8c74-4a7b-acd4-13fbcd5f89f7" class="">레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k) 했을 때, n=2^3의 경우, 2^3 -&gt; 2^2 -&gt; 2^1 -&gt; 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다.</p><figure id="7403ebd7-200f-4674-ad97-f9720634b453" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-002.png"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-002.png"/></a></figure><p id="052ae21f-9648-476c-9585-6d4828fa76fd" class="">이것을 일반화하면 n=2^k의 경우, <strong>k(k=log₂n)</strong> 임을 알 수 있다.</p></div></p><p id="4786fe18-d74e-4bb7-b407-f730dfca39e9" class="">02.각 순환 호출 단계의 비교 연산 <code>(n)</code><div class="indented"><p id="f5e9eed5-f05c-4831-a2e1-64f3fd4f9c11" class="">각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 <strong>평균 n번</strong> 정도의 비교가 이루어진다.</p></div></p><p id="d589cc69-070f-4885-9692-72c0d96d26cd" class="">따라서, 최선의 시간복잡도는 <code>순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = nlog₂n</code> 가 된다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.</p></li></ul><ul id="e7d471ba-640e-4188-b32f-ddd11493ab55" class="bulleted-list"><li style="list-style-type:disc"><strong>최악의 경우(Worst cases) : T(n) = O(n^2)</strong><p id="89ca4b3c-d413-4004-bdc0-78eb4cfab3cd" class="">최악의 경우는 정렬하고자 하는 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있는 경우다.</p><p id="1c4e9540-7d9b-41ca-8a37-ecf98334e29e" class="">01.비교 횟수 <code>(n)</code><div class="indented"><figure id="af1c0b1a-e962-4e01-b4df-ff09f8d9a766" class="image"><a href="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-003.png"><img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-003.png"/></a></figure><p id="a20cffdd-56d1-4cd7-b2de-0a2a9b8173a7" class="">레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 순환 호출의 깊이는 <strong>n</strong> 임을 알 수 있다.</p></div></p><p id="0c745e47-66a0-46d2-89f3-6735fc279a2d" class="">02.각 순환 호출 단계의 비교 연산 <code>(n)</code><div class="indented"><p id="d5b602ea-5b92-46b9-98f7-f1a75dfe361b" class="">각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번 ** 정도의 비교가 이루어진다.</p></div></p><p id="9466980b-fffb-4104-9de1-8ae89c741d9a" class="">따라서, 최악의 시간복잡도는 <code>순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = n^2</code> 다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.</p><p id="84acf48f-5445-4808-a462-b6233d43b0c3" class="">
</p></li></ul><h3 id="76b6c53c-d5c3-4f14-998b-4fb5dfea0fa4" class=""><strong>평균의 경우(Average cases) : T(n) = O(nlog₂n)</strong></h3><p id="5dc978f1-8cf7-45df-90ee-d13cfdc34ec8" class="">
</p><h3 id="1e5271e2-84e4-4575-b392-93557a891e65" class=""><strong>공간복잡도</strong></h3><p id="5a46892b-511f-448c-b6ed-27f1066163f2" class="">주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)**이다.</p><p id="e8f7fa89-1264-4771-b213-a7897d0f973a" class="">
</p><h3 id="59bbfcb6-f6f9-4f51-ae47-097cd35f10f1" class=""><strong>장점</strong></h3><ul id="41599eae-8e5a-4aaa-a7eb-ecaa83f7c983" class="bulleted-list"><li style="list-style-type:disc">불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.</li></ul><ul id="fb990f92-d755-4de1-ac8f-6c2360ed3ce8" class="bulleted-list"><li style="list-style-type:disc">정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.</li></ul><p id="e1a74bf4-2e55-45bc-abe0-2c3d0b849e04" class="">
</p><p id="27053660-8f07-4a80-b02c-325a27823574" class=""><strong>단점</strong></p><ul id="44081e46-429f-42bc-b7dd-3c78bd0894f0" class="bulleted-list"><li style="list-style-type:disc"><strong>불안정 정렬(Unstable Sort)</strong> 이다.</li></ul><ul id="f7cef2f4-213c-48c4-8a68-a22e13bdeb34" class="bulleted-list"><li style="list-style-type:disc">정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.</li></ul><p id="cad5704a-3736-4d31-9ad9-0fec287abe34" class="">
</p><ul id="2c1a4702-8b03-4368-b858-e05cf666aa60" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="87f95ed5-65f8-4d9c-99a8-e58b7887f7a9" class=""><a href="https://gyoogle.dev/blog/algorithm/Quick%20Sort.html">https://gyoogle.dev/blog/algorithm/Quick Sort.html</a></p><p id="a2a825ca-0742-4ab8-841c-d8c8aa9a91d1" class="">
</p><hr id="0b6b7954-381c-4cba-bcaa-cac4c5a3c4ef"/><p id="7f0b2301-f292-492e-814b-bae8ec5ce17c" class="">
</p><h2 id="21560a4a-9438-4c8c-8440-77761a9e5bd0" class=""><strong>병합 정렬(Merge Sort)</strong></h2><p id="79b7798a-18f2-4962-942b-7b5d4b243d3c" class="">
</p><h3 id="fbb87d83-3b52-4c72-a614-07f9b22149a0" class="">병합 정렬이란</h3><p id="47d2eb3f-e629-44ef-9b52-b2772d5adab0" class="">합병 정렬이라고도 부르며, 분할 정복 방법을 통해 구현한다.</p><p id="dcad3d7f-f770-4fdc-bfc9-840241a532a2" class="">
</p><h3 id="24367c19-de68-4a61-b331-f787b667f0c4" class=""><strong>분할 정복이란?</strong></h3><ul id="8e7e75f1-f111-469a-b8bb-8d440d7c87ae" class="bulleted-list"><li style="list-style-type:disc">큰 문제를 작은 문제 단위로 쪼개면서 해결해나가는 방식</li></ul><ul id="0334883b-0d1b-4a1e-9b97-da1b0c11d2e4" class="bulleted-list"><li style="list-style-type:disc">빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.</li></ul><ul id="6fa7486f-df49-426a-8aaf-9ba6d157ed35" class="bulleted-list"><li style="list-style-type:disc">퀵소트와는 반대로 <code>안정 정렬</code>에 속함</li></ul><p id="36a0a621-702c-4a06-a678-6be069c3d6a7" class="">
</p><h3 id="ad028c84-5d6c-4fa5-a84c-7f579eb80de1" class=""><strong>시간복잡도</strong></h3><table id="ed1a4e0b-7706-4bfa-a674-9f98de1b5e93" class="simple-table"><tbody><tr id="e12034a0-0a81-458c-abb8-5baf679ce354"><td id="c`vc" class="">평균</td><td id="rSwI" class="">최선</td><td id="mip;" class="">최악</td></tr><tr id="c4ca3294-4fff-43cb-8244-77d82713ad14"><td id="c`vc" class="">Θ(nlogn)</td><td id="rSwI" class="">Ω(nlogn)</td><td id="mip;" class="">O(nlogn)</td></tr></tbody></table><p id="dd8247d7-bfb8-467b-a65e-a7996b4f6904" class="">요소를 쪼갠 후, 다시 합병시키면서 정렬해나가는 방식으로, 쪼개는 방식은 퀵정렬과 유사</p><ul id="42a74d73-9c6d-45e0-87b8-7c3b9e9f7203" class="bulleted-list"><li style="list-style-type:disc">mergeSort<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d80f59ba-73fe-4177-a668-4caac1867353" class="code"><code class="language-Java">public void mergeSort(int[] array, int left, int right) {
    
    if(left &lt; right) {
        int mid = (left + right) / 2;
        
        mergeSort(array, left, mid);
        mergeSort(array, mid+1, right);
        merge(array, left, mid, right);
    }
    
}</code></pre><p id="cc8ad419-3fb6-48ce-8a37-3782d40cdc1d" class="">정렬 로직에 있어서 merge() 메소드가 핵심</p></li></ul><p id="1ae02e38-0594-4693-ab87-c69cfdec5705" class="">
</p><h3 id="da20ac29-33ee-4cb4-8b38-19f81270c228" class="">퀵소트와의 차이점</h3><ul id="cc4679c2-960b-487e-885e-44caaca5d8b3" class="bulleted-list"><li style="list-style-type:disc">퀵정렬 : 우선 피벗을 통해 정렬(partition) → 영역을 쪼갬(quickSort)</li></ul><ul id="47802fdf-e08d-4b20-9681-d4fb572f6adc" class="bulleted-list"><li style="list-style-type:disc">합병정렬 : 영역을 쪼갤 수 있을 만큼 쪼갬(mergeSort) → 정렬(merge)</li></ul><p id="4c58ea37-0e75-4758-bbdc-cea59a1635b4" class="">
</p><h3 id="f95bf2d7-541a-4347-ba22-73dd60e9def3" class="">merge()</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e519c9d8-131c-48e2-aa0a-0c5b36773492" class="code"><code class="language-Java">public static void merge(int[] array, int left, int mid, int right) {
    int[] L = Arrays.copyOfRange(array, left, mid + 1);
    int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);
    
    int i = 0, j = 0, k = left;
    int ll = L.length, rl = R.length;
    
    while(i &lt; ll &amp;&amp; j &lt; rl) {
        if(L[i] &lt;= R[j]) {
            array[k] = L[i++];
        }
        else {
            array[k] = R[j++];
        }
        k++;
    }
    
    // remain
    while(i &lt; ll) {
        array[k++] = L[i++];
    }
    while(j &lt; rl) {
        array[k++] = R[j++];
    }
}</code></pre><ul id="e194cb88-149d-4168-9e46-75e87c737fc9" class="bulleted-list"><li style="list-style-type:disc">이미 <strong>합병의 대상이 되는 두 영역이 각 영역에 대해서 정렬이 되어있기 때문</strong>에 단순히 두 배열을 <strong>순차적으로 비교하면서 정렬할 수가 있다.</strong></li></ul><ul id="821ad146-02ac-418f-b5ae-f8539888faec" class="bulleted-list"><li style="list-style-type:disc">★<strong>합병정렬은 순차적</strong>인 비교로 정렬을 진행하므로, <strong>LinkedList의 정렬이 필요할 때 사용하면 효율적</strong>이다.</li></ul><p id="a5534553-4c62-4efd-a2bb-f613180cd3f7" class="">
</p><h3 id="32bf28ba-ee0d-4a04-a599-b06700235970" class="">LinkedList를 퀵정렬을 사용해 정렬하면?</h3><ul id="ca03d36d-13d5-4b3c-8ff3-3ecff77ee793" class="bulleted-list"><li style="list-style-type:disc">성능이 좋지 않음</li></ul><ul id="b2b3c499-374d-4b81-8088-ce2571575eee" class="bulleted-list"><li style="list-style-type:disc">퀵정렬은, 순차 접근이 아닌 <strong>임의 접근이기 때문</strong></li></ul><ul id="78fb777f-389f-450b-828b-722753d91724" class="bulleted-list"><li style="list-style-type:disc"><strong>LinkedList는 삽입, 삭제 연산에서 유용</strong>하지만 <strong>접근 연산에서는 비효율적</strong>임<p id="4bb114f5-b786-4d32-9d47-66affba0ee42" class="">따라서 임의로 접근하는 퀵소트를 활용하면 오버헤드 발생이 증가하게 됨</p><p id="26e0aad3-18d6-43e7-b9a2-71a0f1135845" class="">→ 배열은 인덱스를 이용해서 접근이 가능하지만, LinkedList는 Head부터 탐색해야 함</p><p id="e4372fcb-a913-4fce-b3b2-e5e369eb0893" class="">→ 배열[O(1)] vs LinkedList[O(n)]</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6b8a22a5-5553-458c-8da1-1ab7ce89a16d" class="code"><code class="language-Java">private void solve() {
    int[] array = { 230, 10, 60, 550, 40, 220, 20 };
 
    mergeSort(array, 0, array.length - 1);
 
    for (int v : array) {
        System.out.println(v);
    }
}
 
public static void mergeSort(int[] array, int left, int right) {
    if (left &lt; right) {
        int mid = (left + right) / 2;
 
        mergeSort(array, left, mid);
        mergeSort(array, mid + 1, right);
        merge(array, left, mid, right);
    }
}
 
public static void merge(int[] array, int left, int mid, int right) {
    int[] L = Arrays.copyOfRange(array, left, mid + 1);
    int[] R = Arrays.copyOfRange(array, mid + 1, right + 1);
 
    int i = 0, j = 0, k = left;
    int ll = L.length, rl = R.length;
 
    while (i &lt; ll &amp;&amp; j &lt; rl) {
        if (L[i] &lt;= R[j]) {
            array[k] = L[i++];
        } else {
            array[k] = R[j++];
        }
        k++;
    }
 
    while (i &lt; ll) {
        array[k++] = L[i++];
    }
 
    while (j &lt; rl) {
        array[k++] = R[j++];
    }
}</code></pre></li></ul><p id="e6f10a80-9577-4ade-818f-d8e58d3e5e11" class="">
</p><p id="ea6aec69-e57b-4fba-8c66-b3d8ba3e8877" class="">
</p><ul id="d6d51cd3-f796-47a0-9c8a-0466199b941a" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="904462bb-36a4-4ce7-834d-0699f5dca2ad" class=""><a href="https://gyoogle.dev/blog/algorithm/Merge%20Sort.html">https://gyoogle.dev/blog/algorithm/Merge Sort.html</a></p><p id="05fca26b-8c80-4a3b-92c6-c15e0ab0c3d5" class="">
</p><hr id="f9b49dec-f079-4941-a55d-b059be69bc3c"/><p id="8fc9e153-6ad0-4f5f-aa01-95b12266cbd6" class="">
</p><h2 id="6ba3936d-d973-4256-b93c-8e48e392b53d" class=""><strong>힙 정렬(Heap Sort)</strong></h2><p id="7910bb79-67e5-42bd-ae5f-e69fb7f74086" class="">
</p><h3 id="ebef537d-ac6c-45e5-bc49-b77ff8fc8e44" class="">힙 정렬이란?</h3><ul id="e37b56fb-d100-405f-b76c-6ae19cf3b467" class="bulleted-list"><li style="list-style-type:disc">완전 이진 트리를 기본으로 하는 힙(Heap) 자료구조를 기반으로한 정렬 방식<p id="48d98e24-ec4f-409e-a0a6-8d6d9e80f39b" class="">→ <strong>완전 이진 트리란 </strong>삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리</p></li></ul><ul id="c956c52d-0b85-4b3a-a12e-86a5e7f75258" class="bulleted-list"><li style="list-style-type:disc">힙 소트는 <code>불안정 정렬</code>에 속함</li></ul><p id="525f047d-4e76-48e7-9a91-e292afa7c5d0" class="">
</p><h3 id="6ea916de-e6fb-42d3-b743-f32efd561eb4" class=""><strong>시간복잡도</strong></h3><table id="127a08dc-71df-4bbb-8d60-99b8de090cfa" class="simple-table"><tbody><tr id="ff42d64a-697e-4d76-b800-5e9ed08923cb"><td id="BpCd" class="">평균</td><td id="&lt;nk}" class="">최선</td><td id="JWw^" class="">최악</td></tr><tr id="29cee89e-0481-453a-abef-21245fffd13a"><td id="BpCd" class="">Θ(nlogn)</td><td id="&lt;nk}" class="">Ω(nlogn)</td><td id="JWw^" class="">O(nlogn)</td></tr></tbody></table><h3 id="7985c945-b9a4-4613-a87b-6920dc416f09" class=""><strong>과정</strong></h3><ol type="1" id="edfeeba1-74f7-4863-9cf5-c30c6775c89a" class="numbered-list" start="1"><li>최대 힙을 구성</li></ol><ol type="1" id="ea65a12d-b0bb-43b4-b8b8-d61c10a76bc3" class="numbered-list" start="2"><li>현재 힙 루트는 가장 큰 값이 존재함. 루트의 값을 마지막 요소와 바꾼 후, 힙의 사이즈 하나 줄임</li></ol><ol type="1" id="a5621d33-226d-4aee-bb12-a9140c870e07" class="numbered-list" start="3"><li>힙의 사이즈가 1보다 크면 위 과정 반복</li></ol><figure id="51c4828d-34e2-4f6e-9e01-a963fa391301" class="image"><a href="https://t1.daumcdn.net/cfile/tistory/999896445AD4953023"><img src="https://t1.daumcdn.net/cfile/tistory/999896445AD4953023"/></a></figure><p id="c0994ee6-edab-463a-8953-a6ab390f7c06" class="">루트를 마지막 노드로 대체 (11 → 4), 다시 최대 힙 구성</p><figure id="c120e2e3-10c5-4be8-8014-10fc5df86d5d" class="image"><a href="https://t1.daumcdn.net/cfile/tistory/99E1AD445AD4953015"><img src="https://t1.daumcdn.net/cfile/tistory/99E1AD445AD4953015"/></a></figure><p id="306b60c2-1c44-4246-ae3d-d45c17aeb4a0" class="">이와 같은 방식으로 최대 값을 하나씩 뽑아내면서 정렬하는 것이 힙 소트</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="df2644c4-a83e-4763-ad43-274b54c5f5b8" class="code"><code class="language-Java">public void heapSort(int[] array) {
    int n = array.length;
    
    // max heap 초기화
    for (int i = n/2-1; i&gt;=0; i--){
        heapify(array, n, i); // 1
    }
    
    // extract 연산
    for (int i = n-1; i&gt;0; i--) {
        swap(array, 0, i); 
        heapify(array, i, 0); // 2
    }
}</code></pre><p id="ed847b41-35c4-4d13-914f-61375e5148fe" class="">
</p><h3 id="5c25ee67-edc7-4d82-b9cc-cc9f058f0211" class=""><strong>1번째 heapify</strong></h3><ul id="af98d053-e081-4148-af18-cf6af2f3dd61" class="bulleted-list"><li style="list-style-type:disc">일반 배열을 힙으로 구성하는 역할</li></ul><ul id="f746da0c-c7b2-47e3-b96f-ed1720d72cfd" class="bulleted-list"><li style="list-style-type:disc">자식노드로부터 부모노드 비교<p id="1a89f7ac-7afd-419f-a1ae-44ed4f9bc2dd" class=""><em>n/2-1부터 0까지 인덱스가 도는 이유는?</em></p><p id="54e49121-3453-4cca-b26f-0241f3d8b111" class="">→ 부모 노드의 인덱스를 기준으로 왼쪽 자식노드 (i<em>2 + 1), 오른쪽 자식 노드(i</em>2 + 2)이기 때문</p></li></ul><h3 id="90d947de-010a-4650-b2c6-b4ee56aa1d5d" class=""><strong>2번째 heapify</strong></h3><ul id="72586dea-9c03-4d95-b057-4be98eede0e6" class="bulleted-list"><li style="list-style-type:disc">요소가 하나 제거된 이후에 다시 최대 힙을 구성하기 위함</li></ul><ul id="f59dccac-065a-4402-bec3-edfc2b8a09b8" class="bulleted-list"><li style="list-style-type:disc">루트를 기준으로 진행(extract 연산 처리를 위해)</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="130dda9d-c0c5-41ed-bc4d-6f41b169e498" class="code"><code class="language-Java">public void heapify(int array[], int n, int i) {
    int p = i;
    int l = i*2 + 1;
    int r = i*2 + 2;
    
    //왼쪽 자식노드
    if (l &lt; n &amp;&amp; array[p] &lt; array[l]) {
        p = l;
    }
    //오른쪽 자식노드
    if (r &lt; n &amp;&amp; array[p] &lt; array[r]) {
        p = r;
    }
    
    //부모노드 &lt; 자식노드
    if(i != p) {
        swap(array, p, i);
        heapify(array, n, p);
    }
}</code></pre><p id="9d25c0e1-8968-4c4a-9f15-237fa9df5881" class=""><strong>다시 최대 힙을 구성할 때까지</strong> 부모 노드와 자식 노드를 swap하며 재귀 진행</p><p id="302317b7-7dc3-45f9-858d-23e00f8cc80c" class="">퀵정렬과 합병정렬의 성능이 좋기 때문에 힙 정렬의 사용빈도가 높지는 않음.</p><p id="555b4bbd-b7e7-4f45-8a96-6a5442efe09a" class="">하지만 힙 자료구조가 많이 활용되고 있으며, 이때 함께 따라오는 개념이 <code>힙 소트</code></p><p id="3a11a7ab-cb72-422e-a82b-7d8d0db1e5f7" class="">
</p><h3 id="b4494759-a08b-41ce-a363-15add54b77ba" class=""><strong>힙 소트가 유용할 때</strong></h3><ul id="e45892fd-ce3f-449a-900e-d09ac36ac075" class="bulleted-list"><li style="list-style-type:disc">가장 크거나 가장 작은 값을 구할 때<p id="1163d89a-ff6d-4b93-ba74-74a47293dc5f" class="">→ 최소 힙 or 최대 힙의 루트 값이기 때문에 한번의 힙 구성을 통해 구하는 것이 가능</p></li></ul><ul id="39647515-4def-46ef-bbc9-0f537995f688" class="bulleted-list"><li style="list-style-type:disc">최대 k 만큼 떨어진 요소들을 정렬할 때<p id="6647c369-1ca6-4052-bd54-426d6d924b19" class="">→ 삽입정렬보다 더욱 개선된 결과를 얻어낼 수 있음</p></li></ul><p id="386b8ef0-b17f-4b0e-98c2-1e08771a6273" class="">
</p><h3 id="099ae1e6-572d-4964-a0d9-46b83e8bbbee" class="">전체 코드</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="34a0b250-efb6-481b-af2c-1c15061f323c" class="code"><code class="language-Java">private void solve() {
    int[] array = { 230, 10, 60, 550, 40, 220, 20 };
 
    heapSort(array);
 
    for (int v : array) {
        System.out.println(v);
    }
}
 
public static void heapify(int array[], int n, int i) {
    int p = i;
    int l = i * 2 + 1;
    int r = i * 2 + 2;
 
    if (l &lt; n &amp;&amp; array[p] &lt; array[l]) {
        p = l;
    }
 
    if (r &lt; n &amp;&amp; array[p] &lt; array[r]) {
        p = r;
    }
 
    if (i != p) {
        swap(array, p, i);
        heapify(array, n, p);
    }
}
 
public static void heapSort(int[] array) {
    int n = array.length;
 
    // init, max heap
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapify(array, n, i);
    }
 
    // for extract max element from heap
    for (int i = n - 1; i &gt; 0; i--) {
        swap(array, 0, i);
        heapify(array, i, 0);
    }
}
 
public static void swap(int[] array, int a, int b) {
    int temp = array[a];
    array[a] = array[b];
    array[b] = temp;
}</code></pre><p id="be6d7ce1-7d08-4886-b65a-37b00e3cb2e3" class="">
</p><ul id="ea006b2e-311e-4f49-af03-822a913c4c16" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="b11c352e-c59e-4255-b8e9-c804bb3a80b4" class=""><a href="https://gyoogle.dev/blog/algorithm/Heap%20Sort.html">https://gyoogle.dev/blog/algorithm/Heap Sort.html</a></p><p id="d470fa93-a77d-43b4-8a39-0d156bb06cf7" class="">
</p><hr id="9bd1ca85-a206-4771-9f44-886f92184e1e"/><p id="f6b6f688-5e19-4b5a-8ff1-34bfecdb2ae9" class="">
</p><h2 id="31ed87ff-02e0-48c0-906c-2f6bc37350f6" class=""><strong>기수 정렬(Radix sort)</strong></h2><p id="1dfe84ae-eee5-45cf-a595-71909c4a4785" class="">
</p><h3 id="b97a83a2-f11e-4e2d-92a8-108125ed74c2" class=""><strong>Comparison Sort</strong></h3><ul id="b885862f-f798-4dc2-a56a-60484a0789a1" class="bulleted-list"><li style="list-style-type:disc">N개 원소의 배열이 있을 때, 이를 모두 정렬하는 가짓수는 N!이다.<p id="474610da-4a27-4f39-b2fd-0cbdae955dbe" class="">따라서, Comparison Sort를 통해 생기는 <span style="border-bottom:0.05em solid">트리의 말단 노드</span>가 N! 이상의 노드 갯수를 갖기 위해서는, 2^h &gt;= N! 를 만족하는 h를 가져야 하고, 이 식을 h &gt; O(nlgn)을 가져야 한다. (h는 트리의 높이,,, 즉 Comparison sort의 시간 복잡도임)</p></li></ul><ul id="94376a6a-dc23-494b-ab99-52adeb5b933b" class="bulleted-list"><li style="list-style-type:disc">이런 O(nlgn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것이다.</li></ul><p id="73aef578-f85c-4213-8f20-5568e9aae2e9" class="">
</p><h3 id="ee078d05-bc28-419e-b11b-f72ea9aae2d9" class=""><strong>Radix sort</strong></h3><ul id="78389b2d-5d43-4dce-8eb9-0731be717c0b" class="bulleted-list"><li style="list-style-type:disc">데이터를 구성하는 기본 요소 (Radix) 를 이용하여 정렬을 진행하는 방식</li></ul><ul id="68a62adc-81e3-4867-9a6c-7cb4b4db7195" class="bulleted-list"><li style="list-style-type:disc">입력 데이터의 최대값에 따라서 Counting Sort의 비효율성을 개선하기 위해서, Radix Sort를 사용할 수 있음.<p id="3cfeb4b8-3a89-44a8-8e9a-fb06641af881" class="">자릿수의 값 별로 (예) 둘째 자리, 첫째 자리) 정렬을 하므로, 나올 수 있는 값의 최대 사이즈는 9임 (범위 : 0 ~ 9)</p></li></ul><ul id="c685421a-f632-4219-8e68-f4e9bf21106b" class="bulleted-list"><li style="list-style-type:disc">시간 복잡도 : O(d * (n + b))<ul id="24829961-b941-407a-9d1f-5be2685cc77c" class="bulleted-list"><li style="list-style-type:circle">&gt; d는 정렬할 숫자의 자릿수, b는 10 (k와 같으나 10으로 고정되어 있다.)</li></ul><p id="636ae7c2-4215-4027-a9f2-259f63fda1a9" class="">( Counting Sort의 경우 : O(n + k) 로 배열의 최댓값 k에 영향을 받음 )</p></li></ul><ul id="ee1ebec7-bddc-487a-897c-4ff35bbc49f8" class="bulleted-list"><li style="list-style-type:disc">장점 : 문자열, 정수 정렬 가능</li></ul><ul id="d69127ec-fffb-4b37-891d-7065c064e0dd" class="bulleted-list"><li style="list-style-type:disc">단점 : 자릿수가 없는 것은 정렬할 수 없음. (부동 소숫점)<p id="c1461585-6f84-4d84-8a4a-d48d761395a6" class="">중간 결과를 저장할 bucket 공간이 필요함.</p></li></ul><p id="24ffdb17-359d-4591-806c-561b4bfbcda9" class="">
</p><h3 id="3297e3df-2eb7-48ee-983b-3e87229e6f12" class=""><strong>소스 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="61ef2c11-7bc0-4238-aa85-ae14fba81a08" class="code"><code class="language-Java">void countSort(int arr[], int n, int exp) {
	int buffer[n];
    int i, count[10] = {0};
    
    // exp의 자릿수에 해당하는 count 증가
    for (i = 0; i &lt; n; i++){
        count[(arr[i] / exp) % 10]++;
    }
    // 누적합 구하기
    for (i = 1; i &lt; 10; i++) {
        count[i] += count[i - 1];
    }
    // 일반적인 Counting sort 과정
    for (i = n - 1; i &gt;= 0; i--) {
        buffer[count[(arr[i]/exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    for (i = 0; i &lt; n; i++){
        arr[i] = buffer[i];
    }
}

void radixsort(int arr[], int n) {
     // 최댓값 자리만큼 돌기
    int m = getMax(arr, n);
    
    // 최댓값을 나눴을 때, 0이 나오면 모든 숫자가 exp의 아래
    for (int exp = 1; m / exp &gt; 0; exp *= 10) {
        countSort(arr, n, exp);
    }
}
int main() {
    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
    int n = sizeof(arr) / sizeof(arr[0]);			// 좋은 습관
    radixsort(arr, n);
    
    for (int i = 0; i &lt; n; i++){
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}</code></pre><p id="751dda18-07b7-478e-9d48-7f05f3766efc" class="">
</p><ul id="239ef7f2-430b-4900-9f39-9f110545df13" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="8e31d366-e9b9-49b6-95da-a9d357b0a8ea" class=""><a href="https://gyoogle.dev/blog/algorithm/Radix%20Sort.html">https://gyoogle.dev/blog/algorithm/Radix Sort.html</a></p><p id="19d5c876-94c6-4545-980f-0f025c8a04fd" class="">
</p><hr id="430f8849-3047-4f42-898a-2d04a6feb1a8"/><p id="46ef1467-536f-4316-b5f9-52811c812f44" class="">
</p><h2 id="0f87ba65-02ab-4189-8ebb-b561c6825b03" class=""><strong>계수 정렬(Counting Sort)</strong></h2><p id="fd3f6541-c50a-445b-a85f-9c36985f8d1c" class="">
</p><h3 id="bbfabfbf-cf1c-407a-9cd9-f58e0e4c027d" class="">계수 정렬이란</h3><ul id="89be6ecf-b037-4e29-bb51-27be29840a8b" class="bulleted-list"><li style="list-style-type:disc">N개 원소의 배열이 있을 때, 이를 모두 정렬하는 가짓수는 N!이다.<p id="7b3790ae-5dc1-4143-9375-b5576e228e89" class="">따라서, Comparison Sort를 통해 생기는 <span style="border-bottom:0.05em solid">트리의 말단 노드</span>가 N! 이상의 노드 갯수를 갖기 위해서는, 2^h &gt;= N! 를 만족하는 h를 가져야 하고, 이 식을 h &gt; O(nlgn)을 가져야 한다. (h는 트리의 높이,,, 즉 Comparison sort의 시간 복잡도이다.)</p></li></ul><ul id="42c27b1e-6b7b-4e3c-b135-4440c6480fc8" class="bulleted-list"><li style="list-style-type:disc">이런 O(nlgn)을 줄일 수 있는 방법은 Comparison을 하지 않는 것이다.</li></ul><p id="113735ce-6b53-4113-b9f7-5c2c2bb4b418" class="">
</p><h3 id="0383404c-ea8c-41d4-a9a3-cbfdf4a96055" class=""><strong>Counting Sort 과정</strong></h3><ul id="675406fd-399d-433e-864e-e9e794004d3b" class="bulleted-list"><li style="list-style-type:disc">시간 복잡도 : O(n + k) -&gt; k는 배열에서 등장하는 최대값</li></ul><ul id="d06043a5-3cdd-49f3-ad1f-f6cf38900037" class="bulleted-list"><li style="list-style-type:disc">공간 복잡도 : O(k) -&gt; k만큼의 배열을 만들어야 함.</li></ul><ul id="af117ae9-9486-44cf-904b-4b4c393b7869" class="bulleted-list"><li style="list-style-type:disc">Counting이 필요 : 각 숫자가 몇 번 등장했는지 센다.</li></ul><p id="d5b50641-529e-44e9-8a12-e122a674617c" class="">
</p><h3 id="d6bf6cc2-75a0-41f8-87b0-0666133d4b85" class=""><strong>소스 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bfc55fbe-4d12-4be1-9015-14361ffe971b" class="code"><code class="language-Java">int arr[5]; 		// [5, 4, 3, 2, 1]
int sorted_arr[5];
// 과정 1 - counting 배열의 사이즈를 최대값 5가 담기도록 크게 잡기
int counting[6];	// 단점 : counting 배열의 사이즈의 범위를 가능한 값의 범위만큼 크게 잡아야 하므로, 비효율적이 됨.

// 과정 2 - counting 배열의 값을 증가해주기.
for (int i = 0; i &lt; arr.length; i++) {
    counting[arr[i]]++;
}
// 과정 3 - counting 배열을 누적합으로 만들어주기.
for (int i = 1; i &lt; counting.length; i++) {
    counting[i] += counting[i - 1];
}
// 과정 4 - 뒤에서부터 배열을 돌면서, 해당하는 값의 인덱스에 값을 넣어주기.
for (int i = arr.length - 1; i &gt;= 0; i--) {
    counting[arr[i]]--;
    sorted_arr[counting[arr[i]]] = arr[i];
}</code></pre><p id="1bddf1c5-2f65-46d0-89f3-d54c5b89021b" class="">
</p><ul id="a5696c32-7e0e-4dde-bdc8-997114234cba" class="bulleted-list"><li style="list-style-type:disc">사용 : 정렬하는 숫자가 특정한 범위 내에 있을 때 사용<p id="1e9e4c95-73cb-471c-85f5-da1be9b0caa8" class="">(Suffix Array 를 얻을 때, 시간복잡도 O(nlgn)으로 얻을 수 있음.)</p></li></ul><ul id="1d73c765-4a4c-4464-a421-e49ab696aab0" class="bulleted-list"><li style="list-style-type:disc">장점 : O(n) 의 시간복잡도</li></ul><ul id="10a6a64b-f881-4751-b0d3-2c7493e0644a" class="bulleted-list"><li style="list-style-type:disc">단점 : 배열 사이즈 N 만큼 돌 때, 증가시켜주는 Counting 배열의 크기가 큼.<p id="f5372dea-6a48-42ed-8490-340c7820feec" class="">(메모리 낭비가 심함)</p><p id="91366ea4-beb6-4967-b2a3-2b6395338867" class="">
</p></li></ul><ul id="b3b217a4-e3b9-4b00-9a90-8d114e988076" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="111f640e-bf86-4f9b-83b2-aaaf7f6a96fa" class=""><a href="https://gyoogle.dev/blog/algorithm/Counting%20Sort.html">https://gyoogle.dev/blog/algorithm/Counting Sort.html</a></p><p id="7b206789-7b03-4571-9075-fb9578561be1" class="">
</p><hr id="4e67e05f-4e28-4de1-a854-a583d3aa3ba0"/><p id="a214e67a-6e92-445b-8bc4-c83afa3c9671" class="">
</p><h2 id="3e2bb9af-03c3-4a1b-b968-3d586340e34b" class=""><strong>이분 탐색(Binary Search)</strong></h2><p id="c2c5010b-7b28-4203-a27a-e24b8d14d399" class="">
</p><h3 id="5c2f8988-66b9-4b1f-af07-bb7a03ea13a9" class="">이분탐색이란</h3><ul id="503c1aab-8fd9-4a64-b298-2001702c9eb5" class="bulleted-list"><li style="list-style-type:disc">탐색 범위를 두 부분으로 분할하면서 찾는 방식이다.</li></ul><ul id="8edcea7f-ac9b-440b-a709-8debda6343c1" class="bulleted-list"><li style="list-style-type:disc">처음부터 끝까지 돌면서 탐색하는 것보다 훨씬 빠른 장점을 가진다.</li></ul><ul id="1ebcffa2-428e-4cb9-80ef-b04c6b8e3b4f" class="bulleted-list"><li style="list-style-type:disc"><code>시간복잡도<br/>전체 탐색 : O(N)<br/>이분 탐색 : O(logN)<br/></code></li></ul><h3 id="0d2ed3a8-e7e8-4de5-9ef6-6307665eaa80" class=""><strong>진행 순서</strong></h3><ul id="55953717-2405-450a-9455-6b5acff2d000" class="bulleted-list"><li style="list-style-type:disc">우선 정렬을 해야 한다.</li></ul><ul id="2bc5d288-a495-4706-92bc-6150435bde94" class="bulleted-list"><li style="list-style-type:disc">left와 right로 mid 값 설정한다.</li></ul><ul id="9a607f8b-03ee-483e-ae14-2b3f820a89b1" class="bulleted-list"><li style="list-style-type:disc">mid와 내가 구하고자 하는 값과 비교한다.</li></ul><ul id="a65d888a-a09d-4fc6-a9e8-093b7ac69ecb" class="bulleted-list"><li style="list-style-type:disc">구할 값이 mid보다 높으면 : left = mid+1 구할 값이 mid보다 낮으면 : right = mid - 1</li></ul><ul id="01812b1b-bb84-4909-9dbd-5796ed6aa2a2" class="bulleted-list"><li style="list-style-type:disc">left &gt; right가 될 때까지 계속 반복한다.</li></ul><p id="848c0e4c-5a7c-429c-b373-7cb088c5171b" class="">
</p><h3 id="d224c383-7571-43b4-9d9d-d51b8666d013" class=""><strong>소스 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b87e6c9b-f2e0-4947-8269-e4b1117dd9e8" class="code"><code class="language-Java">public static int solution(int[] arr, int M) { // arr 배열에서 M을 찾자
	
    Arrays.sort(arr); // 정렬
	
    int start = 0;
    int end = arr.length - 1;
    int mid = 0;

    while (start &lt;= end) {
        mid = (start + end) / 2;
        if (M == arr[mid]) {
            return mid;
        }else if (arr[mid] &lt; M) {
            start = mid + 1;
        }else if (M &lt; arr[mid]) {
            end = mid - 1;
        }
    }
    throw new NoSuchElementException(&quot;타겟 존재하지 않음&quot;);
}</code></pre><p id="741427c2-e257-4bcd-b6e4-6aba2e947918" class="">
</p><ul id="8e5841a7-722a-43c5-8b10-6a323c76cade" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="6c69d086-12b7-4a07-812d-ae0e0c8e3fee" class=""><a href="https://gyoogle.dev/blog/algorithm/Binary%20Search.html">https://gyoogle.dev/blog/algorithm/Binary Search.html</a></p><p id="1578f5ae-a1cf-4927-9913-960634e67405" class="">
</p><hr id="e827258b-9476-4af6-b87d-a8f0ba25d3b4"/><p id="46fd1c68-303b-422c-932e-2e153d9bf536" class="">
</p><h2 id="bba60f5d-d8b6-4a1d-8ed9-d52f73bf90d1" class=""><strong>해시 테이블(Hash Table)</strong></h2><p id="bb3522f2-d6d4-4278-b5e0-f5a158783703" class="">
</p><h3 id="06982c57-7246-4181-b63e-539267d8cd9e" class="">해시 테이블이란</h3><ul id="3e7e539c-728f-433d-9b1d-f5b8d85e83f0" class="bulleted-list"><li style="list-style-type:disc">브루트 포스(완전 탐색)으로는 시간초과에 빠지게 되는 문제에서는 해시를 적용시켜야 한다.</li></ul><ul id="39201bd3-2df2-46fa-823f-5fe79b5f59f5" class="bulleted-list"><li style="list-style-type:disc">N(1~100000)의 값만큼 문자열이 입력된다.</li></ul><ul id="493dfa90-7434-4ea7-8ee3-b3af8d39e121" class="bulleted-list"><li style="list-style-type:disc">처음 입력되는 문자열은 &quot;OK&quot;, 들어온 적이 있던 문자열은 &quot;문자열+index&quot;로 출력한다.</li></ul><p id="a57d3e4e-d2ed-4ed6-b22f-c6f689fc0517" class="">
</p><h3 id="d9b01fe2-4abb-44b1-a450-175d6a0eaff3" class="">ex)</h3><h3 id="5191ce34-d975-44a7-9ccc-4baef6ee6472" class=""><strong>Input</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3f0ae08e-524b-4858-a4ba-e9e1f27eb4ec" class="code"><code class="language-Java">5
abcd
abc
abcd
abcd
ab</code></pre><h3 id="030adcd8-060d-4d94-90bd-a82076d6ffcc" class=""><strong>Output</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7dff9210-5893-4f81-9274-654ee132d002" class="code"><code class="language-Java">OK
OK
abcd1
abcd2
OK</code></pre><p id="656695ee-d87e-4653-9dc0-220570f32446" class="">똑같은 문자열이 들어왔는지 체크해보고, 들어온 문자열은 인덱스 번호를 부여해서 출력해준다.</p><p id="2659e4eb-ca3f-46d0-ada0-efe943467d0f" class="">하지만, 현재 N값은 최대 10만이다. 브루트 포스로 접근하면 N^2이 되므로 100억번의 연산이 필요해서 시간초과에 빠질 것이다. 따라서 **&#x27;해시 테이블&#x27;**을 이용해 해결해야 한다.</p><p id="0ab16451-a545-46f5-97a6-1a4d7ae97806" class="">입력된 문자열 값을 해시 키로 변환시켜 저장하면서 최대한 시간을 줄여나가도록 구현해야 한다.</p><p id="a5d5c253-21e1-4873-803e-2d599d5ee7cb" class="">
</p><h3 id="7e613e83-793c-4922-881b-84ae0fd6232c" class=""><strong>전체 소스코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e6b99531-21dc-48ee-b1cb-945f1c65fd9e" class="code"><code class="language-Java">package CodeForces;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Solution {
	
	static final int HASH_SIZE = 1000;
	static final int HASH_LEN = 400;
	static final int HASH_VAL = 17; // 소수로 할 것
	
	static int[][] data = new int[HASH_SIZE][HASH_LEN];
	static int[] length = new int[HASH_SIZE];
	static String[][] s_data = new String[HASH_SIZE][HASH_LEN];
	static String str;
	static int N;

	public static void main(String[] args) throws Exception {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();
		
		N = Integer.parseInt(br.readLine()); // 입력 수 (1~100000)
		
		for (int i = 0; i &lt; N; i++) {
			
			str = br.readLine();
			
			int key = getHashKey(str);
			int cnt = checking(key);
			
			if(cnt != -1) { // 이미 들어왔던 문자열
				sb.append(str).append(cnt).append(&quot;\n&quot;);
			}
			else sb.append(&quot;OK&quot;).append(&quot;\n&quot;);
		}
		
		System.out.println(sb.toString());
	}
	
	public static int getHashKey(String str) {
		
		int key = 0;
		
		for (int i = 0; i &lt; str.length(); i++) {
			key = (key * HASH_VAL) + str.charAt(i) + HASH_VAL;
		}
		
		if(key &lt; 0) key = -key; // 만약 key 값이 음수면 양수로 바꿔주기
		
		return key % HASH_SIZE;
		
	}
	
	public static int checking(int key) {
		
		int len = length[key]; // 현재 key에 담긴 수 (같은 key 값으로 들어오는 문자열이 있을 수 있다)
		
		if(len != 0) { // 이미 들어온 적 있음
			
			for (int i = 0; i &lt; len; i++) { // 이미 들어온 문자열이 해당 key 배열에 있는지 확인
				if(str.equals(s_data[key][i])) {
					data[key][i]++;
					return data[key][i];
				}
			}
			
		}
		
		// 들어온 적이 없었으면 해당 key배열에서 문자열을 저장하고 길이 1 늘리기
		s_data[key][length[key]++] = str;

		return -1; // 처음으로 들어가는 경우 -1 리턴
	}

}</code></pre><p id="c677f9b7-a162-4be5-88f3-849ccc945168" class="">
</p><hr id="e5de1108-f3c1-4e65-8bfd-b501ef349599"/><p id="13912a3e-9533-4612-addf-7d172a07e466" class="">
</p><h2 id="d29e4e9d-068c-4f38-b648-308d7b4635e7" class=""><strong>DFS &amp; BFS</strong></h2><p id="4ce647c3-448a-42b0-a0c7-54abfbbcb471" class="">
</p><h3 id="7921aaf9-a5e8-428d-9092-a986355279cc" class=""><strong>DFS이란</strong></h3><ul id="630441d6-cd0c-41f8-9856-fc96d66f6692" class="bulleted-list"><li style="list-style-type:disc">루트 노드 혹은 임의 노드에서 다음 브랜치로 넘어가기 전에, 해당 브랜치를 모두 탐색하는 방법</li></ul><ul id="90565562-5bc6-42c6-b28c-9cdd36324141" class="bulleted-list"><li style="list-style-type:disc"><strong>스택 or 재귀함수</strong>를 통해 구현한다.</li></ul><ul id="f5d87a5c-b6c9-42d5-9799-fdbf82aa3d1d" class="bulleted-list"><li style="list-style-type:disc">모든 경로를 방문해야 할 경우 사용에 적합하다.</li></ul><figure id="e1fef66d-65fb-4296-963d-a1b80d91f828" class="image"><a href="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif"><img style="width:300px" src="https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif"/></a></figure><h3 id="310ac6fe-c703-4687-9efd-a6cf54a15751" class=""><strong>시간 복잡도</strong></h3><ul id="73034ffa-d19a-4496-b9b0-937d419cb2fa" class="bulleted-list"><li style="list-style-type:disc">인접 행렬 : O(V^2)</li></ul><ul id="4d1cbf61-9a03-4246-a4d1-addd15e08b41" class="bulleted-list"><li style="list-style-type:disc">인접 리스트 : O(V+E)<p id="c0d369c3-b26b-4636-a9be-dc21a9edfa34" class="">*V는 접점, E는 간선을 뜻한다</p></li></ul><p id="36abf378-291b-407e-ae52-019d1ecb46df" class="">
</p><h3 id="7f18339a-6535-493b-9f72-1baec810068c" class=""><strong>소스 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0942fccb-d19e-4f2e-90cb-e2c11ef93290" class="code"><code class="language-Java">#include &lt;stdio.h&gt;int map[1001][1001], dfs[1001];

void init(int *, int size);

void DFS(int v, int N) {

	dfs[v] = 1;
	printf(&quot;%d &quot;, v);

	for (int i = 1; i &lt;= N; i++) {
		if (map[v][i] == 1 &amp;&amp; dfs[i] == 0) {
			DFS(i, N);
		}
	}

}

int main(void) {

	init(map, sizeof(map) / 4);
	init(dfs, sizeof(dfs) / 4);

	int N, M, V;
	scanf(&quot;%d%d%d&quot;, &amp;N, &amp;M, &amp;V);

	for (int i = 0; i &lt; M; i++)
	{
		int start, end;
		scanf(&quot;%d%d&quot;, &amp;start, &amp;end);
		map[start][end] = 1;
		map[end][start] = 1;
	}

	DFS(V, N);

	return 0;
}

void init(int *arr, int size) {
	for (int i = 0; i &lt; size; i++)
	{
		arr[i] = 0;
	}
}</code></pre><p id="0fb5c3da-1393-48ad-a520-90f12c06c3b3" class="">
</p><h3 id="36662a3c-3df9-44cd-94a3-4140034e28be" class=""><strong>BFS</strong></h3><ul id="f5c9493b-2ee5-4986-9087-ce46a18a5d82" class="bulleted-list"><li style="list-style-type:disc">루트 노드 또는 임의 노드에서 인접한 노드부터 먼저 탐색하는 방법이다.</li></ul><ul id="249637ed-7a7f-405f-a7fc-6d7a83cc0be0" class="bulleted-list"><li style="list-style-type:disc"><strong>큐</strong>를 통해 구현한다. (해당 노드의 주변부터 탐색해야하기 때문)</li></ul><ul id="87d4e51a-28eb-4eea-ab61-1d663072a09d" class="bulleted-list"><li style="list-style-type:disc">최소 비용(즉, 모든 곳을 탐색하는 것보다 최소 비용이 우선일 때)에 적합하다.</li></ul><figure id="49cc274d-61af-483f-af5e-a8a48c59591f" class="image"><a href="https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif"><img style="width:300px" src="https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif"/></a></figure><h3 id="66ad8005-415a-458f-8b86-4837444d685f" class=""><strong>시간 복잡도</strong></h3><ul id="e01596c4-8e4a-42b9-99bf-1f92c6b6f585" class="bulleted-list"><li style="list-style-type:disc">인접 행렬 : O(V^2)</li></ul><ul id="165aab2b-d078-4f54-9187-0e3a4810223c" class="bulleted-list"><li style="list-style-type:disc">인접 리스트 : O(V+E)</li></ul><p id="d00f4a9f-6c13-4f1e-bd22-69aac50c29b4" class="">
</p><h3 id="4012679d-7ad6-4571-8c9f-7a17d3572656" class=""><strong>소스 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4872d340-61da-4e21-9dcb-fa1700f5e85b" class="code"><code class="language-Java">#include &lt;stdio.h&gt;int map[1001][1001], bfs[1001];
int queue[1001];

void init(int *, int size);

void BFS(int v, int N) {
	int front = 0, rear = 0;
	int pop;

	printf(&quot;%d &quot;, v);
	queue[rear++] = v;
	bfs[v] = 1;

	while (front &lt; rear) {
		pop = queue[front++];

		for (int i = 1; i &lt;= N; i++) {
			if (map[pop][i] == 1 &amp;&amp; bfs[i] == 0) {
				printf(&quot;%d &quot;, i);
				queue[rear++] = i;
				bfs[i] = 1;
			}
		}
	}

	return;
}

int main(void) {

	init(map, sizeof(map) / 4);
	init(bfs, sizeof(bfs) / 4);
	init(queue, sizeof(queue) / 4);

	int N, M, V;
	scanf(&quot;%d%d%d&quot;, &amp;N, &amp;M, &amp;V);

	for (int i = 0; i &lt; M; i++)
	{
		int start, end;
		scanf(&quot;%d%d&quot;, &amp;start, &amp;end);
		map[start][end] = 1;
		map[end][start] = 1;
	}

	BFS(V, N);

	return 0;
}

void init(int *arr, int size) {
	for (int i = 0; i &lt; size; i++)
	{
		arr[i] = 0;
	}
}</code></pre><p id="151c4fd3-0780-4791-93a5-7fcc1a5f87b9" class="">
</p><ul id="709fb4e3-e3ff-4ae2-a7d8-b6d15aaff318" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="be7fcde0-501b-48d8-b350-121779949de4" class=""><a href="https://gyoogle.dev/blog/algorithm/DFS%20&amp;%20BFS.html">https://gyoogle.dev/blog/algorithm/DFS &amp; BFS.html</a></p><p id="8d2d3834-74f7-4680-8c46-29db3bedac89" class="">
</p><hr id="febd3a85-2700-4626-9b8b-39cab126b893"/><p id="de52650c-3af7-4c58-a2aa-ef5cc88e45ec" class="">
</p><h2 id="55ac7d23-11b8-41b2-9d23-fd8076fc6961" class=""><strong>최장 증가 수열(Longest Increasing Sequence)</strong></h2><p id="6cc29be4-83f0-413a-9d84-654a650a79cb" class="">
</p><h3 id="3cec02f3-8634-43b5-b0d2-4edefcb9f0d1" class="">LIS란</h3><ul id="01cf6c79-5fe8-4085-b0de-c2c9ea765a36" class="bulleted-list"><li style="list-style-type:disc">최장 증가 수열 : 가장 긴 증가하는 부분 수열</li></ul><ul id="cd98620a-b0ac-426a-8051-e48eedf3ae83" class="bulleted-list"><li style="list-style-type:disc">[ 7, <strong>2</strong>, <strong>3</strong>, 8, <strong>4</strong>, <strong>5</strong> ] → 해당 배열에서는 [2,3,4,5]가 LIS로 답은 4</li></ul><p id="fe11ecbb-9ae9-4d2e-a830-9c3a8033cb07" class="">
</p><h3 id="46ec8408-5aba-43c3-a32a-058a48a9cf98" class=""><strong>구현 방법 (시간복잡도)</strong></h3><ol type="1" id="206de703-a12d-48c1-852d-8627e2770a62" class="numbered-list" start="1"><li>DP : O(N^2)</li></ol><ol type="1" id="e89574bf-3607-4a79-aed4-a73b9635924c" class="numbered-list" start="2"><li>Lower Bound : O(NlogN)</li></ol><p id="6b7e96fa-ffbe-49cb-8b1b-b06054d50768" class="">
</p><h3 id="68245162-566f-4c9d-9fb7-fa863366503d" class=""><strong>DP 활용 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0ae3d287-2efa-43f1-8345-df3fe16ced8d" class="code"><code class="language-Java">int arr[] = {7, 2, 3, 8, 4, 5};
int dp[] = new int[arr.length]; // LIS 저장 배열


for(int i = 1; i &lt; dp.length; i++) {
    for(int j = i-1; j&gt;=0; j--) {
        if(arr[i] &gt; arr[j]) {
            dp[i] = (dp[i] &lt; dp[j]+1) ? dp[j]+1 : dp[i];
        }
    }
}

for (int i = 0; i &lt; dp.length; i++) {
	if(max &lt; dp[i]) max = dp[i];
}

// 저장된 dp 배열 값 : [0, 0, 1, 2, 2, 3]
// LIS : dp배열에 저장된 값 중 최대 값 + 1</code></pre><p id="11e06ab5-3811-4a18-9c9d-eef5f55f6718" class="">
</p><ul id="fc5cfa33-caf9-4198-b0cd-385e5a169264" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="0817c75b-7d2b-40c8-ab27-4d677bfb983f" class=""><a href="https://gyoogle.dev/blog/algorithm/LIS.html">https://gyoogle.dev/blog/algorithm/LIS.html</a></p><p id="bba5dd0a-0f92-4f3a-a1b9-012183d94d84" class="">
</p><hr id="f3d594b4-5f45-494f-84bc-14a1072cd2e6"/><p id="0924dad9-7f1f-4cd4-bb74-662e3417e52c" class="">
</p><h2 id="952e4435-ae1c-4da9-9bad-bdc23c49dabe" class=""><strong>최소 공통 조상(Lowest Common Ancestor) 알고리즘</strong></h2><p id="902a85ce-a8c5-44c0-82a7-2bb21775fc09" class="">
</p><h3 id="0a43895d-83c8-4e95-b6a0-53eea260aca8" class="">LCA란</h3><ul id="1a603d32-df65-405c-913f-d1d53f1823dd" class="bulleted-list"><li style="list-style-type:disc">최소 공통 조상 찾는 알고리즘<p id="d948fbd8-016a-4377-b7f0-0d32e4977954" class="">→ 두 정점이 만나는 최초 부모 정점을 찾는 것!</p></li></ul><ul id="64259b0d-19e2-4c78-8b48-8e60fd31b3e9" class="bulleted-list"><li style="list-style-type:disc">ex)</li></ul><figure id="c261b49f-f440-42a9-a466-1205c7039dd1" class="image"><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/lca.png"><img style="width:400px" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/lca.png"/></a></figure><p id="e46d66f9-8b44-461f-b102-9be4d4dcfe7d" class="">4와 5의 LCA는? → 4와 5의 첫 부모 정점은 &#x27;2&#x27;</p><p id="bf2ae30c-8172-478e-a694-d7d0958d721d" class="">4와 6의 LCA는? → 첫 부모 정점은 root인 &#x27;1&#x27;</p><p id="24de28f6-d5b5-4ed5-8db2-352c961937b4" class="">
</p><h2 id="b1f25d59-cd7d-45d2-bc93-42daa510624b" class="">원리</h2><p id="d5daf5b0-9b0e-47f3-8ce4-adcb7c31c78f" class="">해당 정점의 depth와 parent를 저장해두는 방식이다. 현재 그림에서의 depth는 아래와 같을 것이다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1ba65e67-c84b-49e3-9976-1de6ced1229c" class="code"><code class="language-Java">[depth : 정점]
0 → 1(root 정점)
1 → 2, 3
2 → 4, 5, 6, 7</code></pre><p id="5776aa16-7fff-4128-a952-01a9283d9a0f" class="">
</p><p id="c4bc8bad-765c-49bc-be90-cda0a76f3c54" class="">parent는 정점마다 가지는 부모 정점을 저장해둔다. 위의 예시에서 저장된 parent 배열은 아래와 같다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="66a53499-ca3c-468f-b890-0c1ed63d6246" class="code"><code class="language-Java">// 1 ~ 7번 정점 (root는 부모가 없기 때문에 0)
int parent[] = {0, 1, 1, 2, 2, 3, 3}</code></pre><p id="66106c71-65dd-428b-8dad-b97798d15bf0" class="">
</p><p id="547250a6-1022-4dac-8730-db4f50450c0b" class="">이 두 배열을 활용해서 두 정점이 주어졌을 때 LCA를 찾을 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c687b4e9-0b8d-4571-becd-67212ecd1e73" class="code"><code class="language-Java">// 두 정점의 depth 확인하기
while(true){
	if(depth가 일치)
		if(두 정점의 parent 일치?) LCA 찾음(종료)
        else 두 정점을 자신의 parent 정점 값으로 변경
    else // depth 불일치
        더 depth가 깊은 정점을 해당 정점의 parent 정점으로 변경(depth가 감소됨)
}</code></pre><p id="1c83ba24-9171-4aa0-82bf-5e44b08f5fce" class="">트리 문제에서 공통 조상을 찾아야하는 문제나, 정점과 정점 사이의 이동거리 또는 방문경로를 저장해야 할 경우 사용하면 된다.</p><p id="2f9d2165-280d-4c7f-91bc-fec41dc4c5be" class="">
</p><ul id="4330d0c3-c50b-4e89-bde6-687f485b2d42" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="ca781d2b-e2dc-40f9-bfc0-1a0111b2b930" class=""><a href="https://gyoogle.dev/blog/algorithm/LCA.html">https://gyoogle.dev/blog/algorithm/LCA.html</a></p><p id="1377a453-554c-4f3f-9fd4-b2b4bc51cf51" class="">
</p><hr id="251fdc30-a6a4-41f3-b7aa-6ddaedaa8cc8"/><p id="9ae55245-0e30-40ae-b331-c0e9909f70a1" class="">
</p><h2 id="d93394f5-50d8-4061-8923-3295c0b620c7" class=""><strong>동적 계획법(Dynamic Programming)</strong></h2><p id="e54793c8-410a-4088-a7df-0a2737de4263" class="">
</p><h3 id="ed70d4a3-41d1-4f22-862a-8c0b4f40874e" class="">동적 계획법(DP)이란</h3><ul id="07ad464b-05ee-4ae0-bfcf-5bf2ca9ee80c" class="bulleted-list"><li style="list-style-type:disc">복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법</li></ul><ul id="9c00b3a0-383f-4bb8-9c1c-fe6e8991f065" class="bulleted-list"><li style="list-style-type:disc"><strong>한 가지 문제</strong>에 대해서, <strong>단 한 번만 풀도록</strong> 만들어주는 알고리즘이다.</li></ul><ul id="7d6eec01-8067-46ce-ac45-16948f45477a" class="bulleted-list"><li style="list-style-type:disc">즉, 똑같은 연산을 반복하지 않도록 만들어준다. 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘이라고 할 수 있다.</li></ul><ul id="b2ccb87f-c4ab-48a5-b29e-1ce0406bed82" class="bulleted-list"><li style="list-style-type:disc">동적 계획법은 <strong>Optimal Substructure</strong>에서 효과를 발휘한다.<p id="a3b7420d-fd8e-4d2b-92af-ec743da7be1a" class=""><em>Optimal Substructure</em> : 답을 구하기 위해 이미 했던 똑같은 계산을 계속 반복하는 문제 구조</p></li></ul><h3 id="d5df3382-bba4-4341-bb65-a3d9d9b338a2" class=""><strong>접근 방식</strong></h3><p id="46e8b94f-582c-4d8e-9f5b-0f3f7ae77372" class="">커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법인 분할 정복과 매우 유사하다. 하지만 간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점이 존재한다.</p><p id="c5237397-2a91-44f1-8f36-d801841507ee" class="">즉, 동적 계획법은 간단한 작은 문제들 속에서 &#x27;계속 반복되는 연산&#x27;을 활용하여 빠르게 풀 수 있는 것이 핵심이다.</p><h3 id="c2ad1cbc-30ff-48de-82c0-136d628a0a99" class=""><strong>조건</strong></h3><ul id="f05b226f-48c4-4d74-9abc-f3dcab72c03b" class="bulleted-list"><li style="list-style-type:disc">작은 문제에서 반복이 일어남</li></ul><ul id="32454466-1f0e-4f34-9043-df53a8dc796d" class="bulleted-list"><li style="list-style-type:disc">같은 문제는 항상 정답이 같음</li></ul><p id="5093895f-e0fd-452c-9d4e-85128f4666a0" class="">이 두 가지 조건이 충족한다면, 동적 계획법을 이용하여 문제를 풀 수 있다.</p><p id="bb5c78a7-0307-4d3c-907f-7108dfc65a79" class="">같은 문제가 항상 정답이 같고, 반복적으로 일어난다는 점을 활용해 메모이제이션(Memoization)으로 큰 문제를 해결해나가는 것이다.</p><p id="d9be9929-d7b6-43d2-add1-94c2996b283e" class="">*<em>메모이제이션(Memoization)</em> : 한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식</p><p id="20e09d1f-c222-4af8-8829-032cdf901225" class="">→ 피보나치 수열에서 재귀를 활용하여 풀 경우, 같은 연산을 계속 반복함을 알 수 있다.</p><p id="19d7eb14-e068-4095-9743-432d683959ca" class="">→ 이때, 메모이제이션을 통해 같은 작업을 되풀이 하지 않도록 구현하면 효율적이다.</p><p id="087448bb-d77c-4026-9003-322d3af095b2" class=""><code>fibonacci(5) = fibonacci(4) + fibonacci(3)<br/>fibonacci(4) = fibonacci(3) + fibonacci(2)<br/>fibonacci(3) = fibonacci(2) + fibonacci(1)<br/><br/>이처럼 같은 연산이 계속 반복적으로 이용될 때, 메모이제이션을 활용하여 값을 미리 저장해두면 효율적<br/></code></p><p id="c4418b11-38fa-4d26-a6f1-8d3b810fac1f" class="">피보나치 구현에 재귀를 활용했다면 시간복잡도는 O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.</p><h3 id="603d3b0f-a191-4bb0-947d-49250d8059a4" class=""><strong>구현 방식</strong></h3><ul id="4ae531e2-9438-4725-b275-68b289e853b8" class="bulleted-list"><li style="list-style-type:disc">Bottom-up : 작은 문제부터 차근차근 구하는 방법</li></ul><ul id="96291563-c45a-43b3-9540-52ea26c72c1e" class="bulleted-list"><li style="list-style-type:disc">Top-down : 큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)</li></ul><p id="cdd21434-b445-4809-ab27-5b28a0feb72f" class="">→Bottom-up은 해결이 용이하지만, 가독성이 떨어짐</p><p id="6432a475-e3bb-4699-b0fd-6d7f5f409690" class="">→Top-down은 가독성이 좋지만, 코드 작성이 힘듬</p><p id="1e706b78-2b06-41e5-b1c8-49991ab60703" class="">동적 계획법으로 문제를 풀 때는, 우선 작은 문제부터 해결해나가보는 것이 좋다.</p><p id="4a5e83f3-7f9b-4cfe-9070-32c0e6495e78" class="">작은 문제들을 풀어나가다보면 이전에 구해둔 더 작은 문제들이 활용되는 것을 확인하게 된다.</p><p id="15fecd30-3946-409b-9a4c-722744ee3ec0" class="">
</p><ul id="d1b91639-71f5-4956-aa10-3aff724d5655" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="95fc7b5a-564d-4bc9-8703-6efed917fbea" class=""><a href="https://gyoogle.dev/blog/algorithm/Dynamic%20Programming.html">https://gyoogle.dev/blog/algorithm/Dynamic Programming.html</a></p><p id="6a680a71-0ffb-4e34-84da-43b6c0b7f64d" class="">
</p><hr id="1439a3b0-a88e-4b85-8798-0771cede692e"/><p id="06f29947-e3f1-44e4-a712-84b22ed88185" class="">
</p><h2 id="4fa62bbf-5b68-43b6-ab54-000f0aae2469" class=""><strong>다익스트라(Dijkstra) 알고리즘</strong></h2><p id="080ec346-4acd-48ff-9842-d8eaafd8ca6b" class="">
</p><h3 id="d223c384-e52b-4d3e-b2ac-df3df8e934d0" class="">다일스트라 알고리즘이란</h3><ul id="d5c02648-8d06-4bbd-97fc-6c28f705e680" class="bulleted-list"><li style="list-style-type:disc">DP를 활용한 최단 경로 탐색 알고리즘</li></ul><p id="4d55db34-cf16-4c03-b575-962853982f8f" class="">
</p><figure id="40e92d8c-81af-4b59-bc03-566b4a81a517" class="image"><a href="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif"><img style="width:336px" src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif"/></a></figure><ul id="1e17728c-5086-47b2-99fc-169a4f7895f1" class="bulleted-list"><li style="list-style-type:disc">다익스트라 알고리즘은 특정한 정점에서 다른 모든 정점으로 가는 최단 경로를 기록한다.</li></ul><ul id="d4d2339c-ca1a-419e-98d4-7b7e40190b1f" class="bulleted-list"><li style="list-style-type:disc">여기서 DP가 적용되는 이유는, 굳이 한 번 최단 거리를 구한 곳은 다시 구할 필요가 없기 때문이다. 이를 활용해 정점에서 정점까지 간선을 따라 이동할 때 최단 거리를 효율적으로 구할 수 있다.</li></ul><ul id="2a61ef19-6772-4089-a026-06a2a8597fc0" class="bulleted-list"><li style="list-style-type:disc">다익스트라를 구현하기 위해 두 가지를 저장해야 한다.<p id="189c4f5d-c94b-4825-b7e6-83637199ba51" class="">→ 해당 정점까지의 최단 거리를 저장</p><p id="cff03b2e-4c01-4e83-832a-e044ae109f9c" class="">→ 정점을 방문했는 지 저장</p><p id="17f91138-4f0e-4775-a037-eb9abf7c4819" class="">시작 정점으로부터 정점들의 최단 거리를 저장하는 배열과, 방문 여부를 저장하는 것이다.</p><p id="212db1d5-4fa4-4c3e-bb40-cc218d988c33" class="">
</p></li></ul><h3 id="fbb95fbd-7342-4900-8b8c-1fd29b1c9f6e" class="">다익스트라 알고리즘 순서</h3><ol type="1" id="52dc69ba-e0ab-433d-adb4-bb066f2c8218" class="numbered-list" start="1"><li><strong>최단 거리 값은 무한대 값으로 초기화한다.</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e93df44c-a346-4295-a35b-b05ed1fb42cb" class="code"><code class="language-Java">for(int i = 1; i &lt;= n; i++){
    distance[i] = Integer.MAX_VALUE;
}</code></pre></li></ol><ol type="1" id="7647640d-3dc4-4a79-a148-66912f14bd3f" class="numbered-list" start="2"><li><strong>시작 정점의 최단 거리는 0이다. 그리고 시작 정점을 방문 처리한다.</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3dee070e-c849-4eb4-9152-e012e818da25" class="code"><code class="language-Java">distance[start] = 0;
visited[start] = true;</code></pre></li></ol><ol type="1" id="a99c0710-c476-45d0-a814-9f26b444c0c4" class="numbered-list" start="3"><li>시<strong>작 정점과 연결된 정점들의 최단 거리 값을 갱신한다.</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="079240bb-78a5-4e13-94a9-e1c0f54b7a80" class="code"><code class="language-Java">for(int i = 1; i &lt;= n; i++){
    if(!visited[i] &amp;&amp; map[start][i] != 0) {
    	distance[i] = map[start][i];
    }
}</code></pre></li></ol><ol type="1" id="45fc77cb-d4a6-4bb9-ba1e-845bda18b252" class="numbered-list" start="4"><li><strong>방문하지 않은 정점 중 최단 거리가 최소인 정점을 찾는다.</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="57888190-deb0-4e3f-a811-fc6fb4753b82" class="code"><code class="language-Java">int min = Integer.MAX_VALUE;
int midx = -1;

for(int i = 1; i &lt;= n; i++){
    if(!visited[i] &amp;&amp; distance[i] != Integer.MAX_VALUE) {
    	if(distance[i] &lt; min) {
            min = distance[i];
            midx = i;
        }
    }
}</code></pre></li></ol><ol type="1" id="12e3ee05-be87-4d85-9034-762a33dbb3a9" class="numbered-list" start="5"><li><strong>찾은 정점을 방문 체크로 변경 후, 해당 정점과 연결된 방문하지 않은 정점의 최단 거리 값을 갱신한다.</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8957590b-340e-4c7e-acfc-fd7ba83bde70" class="code"><code class="language-Java">visited[midx] = true;
for(int i = 1; i &lt;= n; i++){
    if(!visited[i] &amp;&amp; map[midx][i] != 0) {
    	if(distance[i] &gt; distance[midx] + map[midx][i]) {
            distance[i] = distance[midx] + map[midx][i];
        }
    }
}</code></pre></li></ol><ol type="1" id="b7b6ca87-5ff7-4304-b519-ace530db5e70" class="numbered-list" start="6"><li><strong>모든 정점을 방문할 때까지 4~5번을 반복한다.</strong></li></ol><p id="72696c7b-1bb3-4971-9687-6f2ebc0a0164" class="">
</p><h3 id="1b90a3cb-22c1-4838-877e-7c2e0aedc84e" class=""><strong>다익스트라 적용 시 알아야할 점</strong></h3><ul id="61b155f1-9eec-4fa2-b68e-74419affe834" class="bulleted-list"><li style="list-style-type:disc">인접 행렬로 구현하면 시간 복잡도는 O(N^2)이다.</li></ul><ul id="97144464-3e15-4269-871e-e55a01d429a5" class="bulleted-list"><li style="list-style-type:disc">인접 리스트로 구현하면 시간 복잡도는 O(N*logN)이다.<p id="7bffb8b8-9079-4b58-950c-0840cf7571f3" class="">→ 선형 탐색으로 시간 초과가 나는 문제는 인접 리스트로 접근해야한다. (우선순위 큐)</p></li></ul><ul id="ce7b8360-db36-4a33-bab9-bb76fd16509a" class="bulleted-list"><li style="list-style-type:disc">간선의 값이 양수일 때만 가능하다.</li></ul><p id="8b1f511c-824c-4694-9af0-a789f4da44a8" class="">
</p><ul id="7ef3b145-6288-4a08-b045-6b5ab5914605" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="c2d1e2df-48bc-4953-bae7-141a97cc3011" class=""><a href="https://gyoogle.dev/blog/algorithm/Dijkstra.html">https://gyoogle.dev/blog/algorithm/Dijkstra.html</a></p><p id="fcd3263b-ffb6-4cb6-b49c-a81b6e37169a" class="">
</p><hr id="da6f371e-8612-48d0-96b1-27dfe44bd554"/><p id="8612daf4-48d4-4d45-bb4f-d781f8e3b194" class="">
</p><h2 id="aa245167-fe0a-449e-a0d8-2c663aa982d2" class=""><strong>비트마스크(BitMask)</strong></h2><p id="b781748a-6a35-41bd-be58-d81e9f2d767d" class="">
</p><h3 id="2ee003f0-895d-4057-80cb-98eba2491f79" class="">비트마스크란</h3><ul id="d7fb56ab-07d4-4ada-bcf3-bff116dab42f" class="bulleted-list"><li style="list-style-type:disc">집합의 요소들의 구성 여부를 표현할 때 유용한 테크닉</li></ul><ul id="5af928ab-6c48-444a-8b94-6f3ed9df979e" class="bulleted-list"><li style="list-style-type:disc">DP나 순열 등, 배열 활용만으로 해결할 수 없는 문제에 활용한다.</li></ul><ul id="7ad10219-e37c-4307-8f64-e3bb216da86c" class="bulleted-list"><li style="list-style-type:disc">작은 메모리와 빠른 수행시간으로 해결이 가능하다. (But, 원소의 수가 많지 않아야 함)</li></ul><ul id="cdb96d1e-b4cb-4d44-9ca6-44663817bb27" class="bulleted-list"><li style="list-style-type:disc">집합을 배열의 인덱스로 표현할 수 있다.</li></ul><ul id="7ead735e-2060-4ba4-8c7f-db7097584dd7" class="bulleted-list"><li style="list-style-type:disc">코드가 간결해진다.</li></ul><p id="6aef8dfa-256e-4bed-8e1e-bebc040617f4" class="">
</p><h3 id="f806eebb-6c55-4862-8c38-17e7969ad8c0" class=""><strong>비트(Bit)란?</strong></h3><ul id="882ffb4c-9494-4845-bc93-5ffa412c17e6" class="bulleted-list"><li style="list-style-type:disc">컴퓨터에서 사용되는 데이터의 최소 단위 (0과 1)</li></ul><ul id="c9e6240f-97cd-413b-9e1a-9ff33640aac9" class="bulleted-list"><li style="list-style-type:disc">우리가 흔히 사용하는 10진수를 2진수로 바꾸면?<p id="481af0aa-5ee4-4af3-b25f-bd9907370ca7" class=""><code>9(10진수) → 1001(2진수)</code></p></li></ul><p id="5333b16a-e503-4495-a33d-2456ba52bc0d" class="">
</p><h3 id="c14e3af6-e00d-4156-9172-a1efd3646be7" class=""><strong>비트마스킹 활용해보기</strong></h3><ul id="aad7e498-eb8f-4d1f-a10e-93900bd11375" class="bulleted-list"><li style="list-style-type:disc">0과 1로, flag 활용하기</li></ul><ul id="4eceaf62-60bf-4690-8498-8e21efd59cce" class="bulleted-list"><li style="list-style-type:disc">ex) [1, 2, 3, 4 ,5] 라는 집합이 있다고 가정<p id="45a5efd1-5011-45cb-bc1a-d621e71fa05c" class="">여기서 임의로 몇 개를 골라 뽑아서 확인을 해야하는 상황이 주어졌다. (즉, 부분집합을 의미)</p><p id="30c7fb6d-fdd1-4747-9e8e-723cd60d33d9" class=""><code>{1}, {2} , ... , {1,2} , ... , {1,2,5} , ... , {1,2,3,4,5}</code></p><p id="7d83844a-406d-4944-8dcc-6cc5645e3375" class="">물론, 간단히 for문 돌려가며 배열에 저장하며 경우의 수를 구할 순 있다.</p><p id="6be04b6f-4522-46d5-a94d-a980e8a90dd1" class="">하지만 비트마스킹을 하면, 각 요소를 인덱스처럼 표현하여 효율적인 접근이 가능하다.</p><p id="a1b0a4b5-f057-469d-ba73-ee9f9d0acdb3" class=""><code>[1,2,3,4,5] → 11111<br/>[2,3,4,5]   → 11110<br/>[1,2,5]     → 10011<br/>[2]         → 00010<br/></code></p><p id="d63a3110-680a-409c-8590-d04b961c2a14" class="">집합의 i번째 요소가 존재하면 <code>1</code>, 그렇지 않으면 <code>0</code>을 의미하는 것이다.</p><p id="8aa1cced-1421-4b5a-92f6-68968b3546c7" class="">이러한 2진수는 다시 10진수로 변환도 가능하다.</p><p id="af6a4337-8804-40e7-817a-dfdd47f96481" class=""><code>11111</code>은 10진수로 31이므로, 부분집합을 <strong>정수를 통해 나타내는 것</strong>이 가능하다는 것을 알 수 있다.</p></li></ul><ul id="d6cb0c25-26b7-4eb8-85ed-81b673b3630d" class="bulleted-list"><li style="list-style-type:disc">31은 [1,2,3,4,5] 전체에 해당하는 부분집합에 해당한다는 의미!<p id="310f570e-5c33-46db-9045-10384f3b47fb" class="">이로써, 해당 부분집합에 i를 추가하고 싶을때 i번째 비트를 1로만 바꿔주면 표현이 가능해졌다.</p><p id="b0f85434-8830-4474-81be-8aa480f93623" class="">이런 행위는 <strong>비트 연산</strong>을 통해 제어가 가능하다.</p></li></ul><h3 id="5188a618-e043-449f-a34f-997529520436" class=""><strong>비트 연산</strong></h3><ul id="bb9fc03f-f8ba-403b-a07e-c50516fd2a52" class="bulleted-list"><li style="list-style-type:disc">AND, OR, XOR, NOT, SHIFT</li></ul><ul id="c26c0ba4-99c4-4f5c-b1fb-7e38fdbee862" class="bulleted-list"><li style="list-style-type:disc">AND(&amp;) : 대응하는 두 비트가 모두 1일 때, 1 반환</li></ul><ul id="77ef5d11-f489-4947-9c6c-2d18b04f0aaa" class="bulleted-list"><li style="list-style-type:disc">OR(|) : 대응하는 두 비트 중 모두 1이거나 하나라도 1일때, 1 반환</li></ul><ul id="bba5532b-7d6b-45b8-8221-cdd738bb2343" class="bulleted-list"><li style="list-style-type:disc">XOR(^) : 대응하는 두 비트가 서로 다를 때, 1 반환</li></ul><ul id="aa0a3ef4-c303-4e89-81e5-f3ac5a4b71d8" class="bulleted-list"><li style="list-style-type:disc">NOT(~) : 비트 값 반전하여 반환</li></ul><ul id="4231f098-6d65-4cda-88fd-526fa8cd72bf" class="bulleted-list"><li style="list-style-type:disc">SHIFT(&gt;&gt;, &lt;&lt;) : 왼쪽 혹은 오른쪽으로 비트 옮겨 반환<ul id="088398f5-7f33-4b74-88ad-42db7af588d4" class="bulleted-list"><li style="list-style-type:circle">왼쪽 시프트 : <code>A * 2^B</code></li></ul><ul id="07b2d991-09e6-4fdc-898b-d5af6f320285" class="bulleted-list"><li style="list-style-type:circle">오른쪽 시프트 : <code>A / 2^B</code></li></ul><p id="bee090fa-f6e2-4d38-9148-4a126a29566b" class=""><code>[왼  쪽] 0001 → 0010 → 0100 → 1000 : 1 → 2 → 4 → 8<br/>[오른쪽] 1000 → 0100 → 0010 → 0001 : 8 → 4 → 2 → 1<br/></code></p><p id="07d64063-3b85-4218-80ec-ccd508196952" class="">
</p></li></ul><h3 id="a810c7ee-aab8-4986-9a71-c9557608f5d1" class=""><strong>구현 코드</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="98f85afb-2708-4f86-8c67-a3f4119b07fc" class="code"><code class="language-Java">#include &lt;stdio.h&gt;int main(void) {
	unsigned char A[100001] = { 0, };
	unsigned char B[100001] = { 0, };
	unsigned char ret[100001] = { 0, };
	int i;

	scanf(&quot;%s %s&quot;, &amp;A, &amp;B);

    // AND
	for (i = 0; i &lt; 100000; i++)
		ret[i] = A[i] &amp; B[i];
	puts(ret);
    
    // OR
	for (i = 0; i &lt; 100000; i++)
		ret[i] = A[i] | B[i];
	puts(ret);

    // XOR
	for (i = 0; i &lt; 100000; i++)
		ret[i] = A[i] != B[i] ? &#x27;1&#x27; : &#x27;0&#x27;;
	puts(ret);

    // ~A
	for (i = 0; i &lt; 100000; i++)
		ret[i] = A[i] == &#x27;1&#x27; ? &#x27;0&#x27; : &#x27;1&#x27;;
	puts(ret);

    // ~B
	for (i = 0; i &lt; 100000; i++)
		ret[i] = B[i] == &#x27;1&#x27; ? &#x27;0&#x27; : &#x27;1&#x27;;
	puts(ret);

	return 0;
}</code></pre><p id="830b2d5c-7c62-4c8d-9ccd-14b636207d91" class="">
</p><h3 id="1a78e5da-e252-4161-b29b-3e8b0d14527d" class="">비트연산활용</h3><p id="d1cfa707-1775-44e8-bf00-b29e03072dff" class=""><strong>1.삽입</strong></p><p id="3e1a3b17-4772-469a-93fc-9b8bb41612f1" class="">현재 이진수로 <code>10101</code>로 표현되고 있을 때, i번째 비트 값을 1로 변경하려고 한다.</p><p id="3e182f83-7890-479d-aef7-9950fbd5d15a" class="">i = 3일 때 변경 후에는 <code>11101</code>이 나와야 한다. 이때는 <strong>OR연산을 활용</strong>한다.</p><p id="a573c47b-d4ce-4bcd-89f9-a78ee00c00f2" class=""><code>10101 | 1 &lt;&lt; 3</code></p><p id="084dcd43-ffcb-4fce-b7ad-27e80cc5ea1f" class=""><code>1 &lt;&lt; 3</code>은 <code>1000</code>이므로 <code>10101 | 01000</code>이 되어 <code>11101</code>을 만들 수 있다.</p><p id="c2de4c85-b157-4468-b0d7-e7971956382e" class=""><strong>2.삭제</strong></p><p id="1ab0c8c8-36c8-483f-8865-fe483488fc5d" class="">반대로 0으로 변경하려면, <strong>AND연산과 NOT 연산을 활용</strong>한다.</p><p id="495bdd4b-a730-45d6-a5f2-dfb1939501ec" class=""><code>11101 &amp; ~1 &lt;&lt; 3</code></p><p id="438962a3-1db0-451f-9743-1b6f14bdc8a5" class=""><code>~1 &lt;&lt; 3</code>은 <code>10111</code>이므로, <code>11101 &amp; 10111</code>이 되어 <code>10101</code>을 만들 수 있다.</p><p id="8a30aecc-7dfc-4b22-ba51-fd2d805581ae" class=""><strong>3.조회</strong></p><p id="17013ec3-86e4-426d-a926-e6532c87ece6" class="">i번째 비트가 무슨 값인지 알려면, <strong>AND연산을 활용</strong>한다.</p><p id="4884ef6e-dfcf-405e-860b-974bf3cf180a" class=""><code>10101 &amp; 1 &lt;&lt; i<br/><br/>3번째 비트 값 : 10101 &amp; (1 &lt;&lt; 3) = 10101 &amp; 01000 → 0<br/>4번째 비트 값 : 10101 &amp; (1 &lt;&lt; 4) = 10101 &amp; 10000 → 10000<br/></code></p><p id="31d5956c-8d91-4da5-bcbe-40ba8237668d" class="">이처럼 결과값이 0이 나왔을 때는 i번째 비트 값이 0인 것을 파악할 수 있다. (반대로 0이 아니면 무조건 1인 것)</p><p id="c1d976ff-7d8f-491f-9735-0376e69ad8f0" class="">이러한 방법을 활용하여 문제를 해결하는 것이 비트마스크다.</p><p id="95118dfa-56da-4109-9acf-a55501a2ac98" class="">
</p><ul id="3f7240a8-8489-42ea-b222-6ab6ae1d12f9" class="bulleted-list"><li style="list-style-type:disc">출처</li></ul><p id="93321384-2631-4f9f-8eb4-523e375cb415" class=""><a href="https://gyoogle.dev/blog/algorithm/BitMask.html">https://gyoogle.dev/blog/algorithm/BitMask.html</a></p><p id="09afeb00-3451-4487-949d-d2da118a5249" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>